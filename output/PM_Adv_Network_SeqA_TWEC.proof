theory PM_Adv_Network_SeqA_TWEC_protocol begin

// Function signature and definition of the equational theory E

functions: BA/1, BB/1, Check_NoEve/2[private,destructor], Correct/2,
           Encode/2, FEC/1, GenKey/1, Measure/2[private,destructor], Noise/1, REC/1,
           RawKey/1, Sample/1, Sift_key/3, fst/1, key/2, mac/2[private,destructor],
           pair/2, snd/1, true/0, verifymac/2
equations:
    Check_NoEve(Sample_key, Sample_key) = true,
    Check_NoEve(Sample(Sift_key(RawKey(key(Noise(kab), BA(ba))), BA(ba),
                                BB(bb))),
                Sample(Sift_key(Measure(Encode(RawKey(key(Noise(kab), BA(ba))), BA(ba)),
                                        BB(bb)),
                                BA(ba), BB(bb))))
  = true,
    Correct(Noise(kab), <FEC(Noise(kab)), REC(Noise(kab))>) = kab,
    GenKey(Sift_key(Measure(Encode(RawKey(key(Noise(kab), BA(ba))), BA(ba)),
                            BB(bb)),
                    BA(ba), BB(bb)))
  = Noise(kab),
    GenKey(Sift_key(RawKey(key(Noise(kab), BA(ba))), BA(ba), BB(bb)))
  = Noise(kab),
    Measure(Encode(RawKey(key(Noise(kab), BA(ba))), BA(ba)), BA(ba))
  = key(Noise(kab), BA(ba)),
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verifymac(mac(msg, key), key) = msg





restriction Eq_checks_succeed:
  "∀ x y #j. (Eq( x, y ) @ #j) ⇒ (x = y)"
  // safety formula

restriction Neq_checks_succeed:
  "∀ x #j. (Neq( x, x ) @ #j) ⇒ (⊥)"
  // safety formula

restriction Basis_Announcement_order_Sequential_Alice_First:
  "∀ A B BA BB #sBA #sBB #rBA #rBB.
    ((((Send_BA( A, B, BA ) @ #sBA) ∧ (Receive_BA( A, B, BA ) @ #rBA)) ∧
      (Send_BB( B, A, BB ) @ #sBB)) ∧
     (Receive_BB( B, A, BB ) @ #rBB)) ⇒
    (((#sBA < #rBA) ∧ (#rBA < #sBB)) ∧ (#sBB < #rBB))"
  // safety formula

restriction OnlyOnce:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Setup:
   [ In( <X, Y> ), Fr( ~sid ) ]
  --[ OnlyOnce( ) ]->
   [ SessionA( X, Y, ~sid ), SessionB( X, Y, ~sid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Out:
   [ Out_QuantumChannel( X, Y, qA ) ]
  --[ EveKnowns( qA ), QChanOut( X, Y, qA ) ]->
   [ Quantum( qA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Adv_Measure:
   [ In( BA ), Quantum( qA ) ]
  --[ EveForgets( qA ) ]->
   [ Out( Measure(qA, BA) ) ]

  /*
  rule (modulo AC) QChan_Adv_Measure:
     [ In( BA ), Quantum( qA ) ] --[ EveForgets( qA ) ]-> [ Out( z ) ]
    variants (modulo AC)
    1. BA    = BA.4
       qA    = qA.4
       z     = Measure(qA.4, BA.4)
    
    2. BA    = BA(x.4)
       qA    = Encode(RawKey(key(Noise(x.5), BA(x.4))), BA(x.4))
       z     = key(Noise(x.5), BA(x.4))
  */

rule (modulo E) QChan_Create_State_new:
   [ In( <X, Y, KE, ba> ) ]
  -->
   [ In_QuantumChannel( X, Y, Encode(key(Noise(KE), BA(ba)), BA(ba)) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Create_State:
   [ In( <X, Y, KE, BA> ) ]
  -->
   [ In_QuantumChannel( X, Y, Encode(RawKey(KE), BA) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Chan_In_Forward:
   [ Quantum( qA ), In( <X, Y> ) ]
  --[ EveForgets( qA ), QChanIn( X, Y, qA ) ]->
   [ In_QuantumChannel( X, Y, qA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ChanOut_Auth:
   [ !AuthSession( roleA, key_roleA ), Out_Auth( roleA, roleB, msg, type ) ]
  --[ AChanOut( roleA, <msg, type> ) ]->
   [
   !Auth( roleA, msg, mac(msg, key_roleA), type ),
   Out( <roleA, roleB, msg, mac(msg, key_roleA), type> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ChanIn_Auth:
   [
   !AuthSession( roleB, key_roleB ), !Auth( roleA, msg, tag, type ),
   In( <roleA, roleB, msg, tag, type> )
   ]
  --[
  Eq( msg, verifymac(tag, key_roleB) ),
  AChanIn( roleA, roleB, <msg, type> )
  ]->
   [ In_Auth( roleA, roleB, msg, type ) ]

  /*
  rule (modulo AC) ChanIn_Auth:
     [
     !AuthSession( roleB, key_roleB ), !Auth( roleA, msg, tag, type ),
     In( <roleA, roleB, msg, tag, type> )
     ]
    --[ Eq( msg, z ), AChanIn( roleA, roleB, <msg, type> ) ]->
     [ In_Auth( roleA, roleB, msg, type ) ]
    variants (modulo AC)
    1. key_roleB
             = key_roleB.8
       tag   = tag.8
       z     = verifymac(tag.8, key_roleB.8)
    
    2. key_roleB
             = x.8
       tag   = mac(x.12, x.8)
       z     = x.12
  */

rule (modulo E) Alice_quantum_phase:
   [ Fr( ~ba ), Fr( ~kab ), SessionA( 'A', Y, ~sid ) ]
  --[ SessionInitA( 'A', Y, ~sid ), Create_A( 'B', ~sid ) ]->
   [
   !AuthSession( 'A', ~sid ),
   Out_QuantumChannel( 'A', Y,
                       Encode(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba))
   ),
   Encoded( 'A', Y, ~sid, RawKey(key(Noise(~kab), BA(~ba))) ),
   AliceBasis( 'A', Y, ~sid, BA(~ba) ), GetBobBasis( 'A', Y, ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Send_BA:
   [ AliceBasis( 'A', Y, ~sid, BA ) ]
  --[ Send_BA( 'A', Y, BA ) ]->
   [ Out_Auth( 'A', Y, BA, 'sift' ), Alice_Sent_BA( 'A', Y, ~sid, BA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Receive_BB:
   [ GetBobBasis( 'A', Y, ~sid ), In_Auth( Y, 'A', BB, 'sift' ) ]
  --[ Receive_BB( Y, 'A', BB ) ]->
   [ Alice_Received_BB( 'A', Y, ~sid, BB ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice_SiftA:
   [
   Encoded( 'A', Y, ~sid, KAraw ), Alice_Sent_BA( 'A', Y, ~sid, BA ),
   Alice_Received_BB( 'A', Y, ~sid, BB )
   ]
  --[ SiftA( 'A', Y, ~sid, Sift_key(KAraw, BA, BB) ) ]->
   [
   SifttedKeyA( 'A', Y, ~sid, BB, Sift_key(KAraw, BA, BB) ),
   SampleKeyA( 'A', Y, ~sid, Sift_key(KAraw, BA, BB) ),
   GetSampleA( 'A', Y, ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Send_SampleA:
   [ SampleKeyA( 'A', Y, ~sid, KA ) ]
  --[ Send_SampleA( 'A', Y, Sample(KA) ) ]->
   [
   Out_Auth( 'A', Y, Sample(KA), 'sample' ),
   Alice_Sent_KsampleA( 'A', Y, ~sid, Sample(KA) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Receive_SampleB:
   [ GetSampleA( 'A', Y, ~sid ), In_Auth( Y, 'A', KsampleB, 'sample' ) ]
  --[ Receive_SampleB( Y, 'A', KsampleB ) ]->
   [ Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Paramater_Estimation_NoEve:
   [
   SifttedKeyA( 'A', Y, ~sid, BB, KA ),
   Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
   Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
   ]
  --[
  Eq( true, Check_NoEve(KsampleA, KsampleB) ), Running_A( 'A', Y, ~sid )
  ]->
   [ KeywithErrorA( 'A', Y, ~sid, KA ) ]

  /*
  rule (modulo AC) Alice_Paramater_Estimation_NoEve:
     [
     SifttedKeyA( 'A', Y, ~sid, BB, KA ),
     Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
     Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
     ]
    --[ Eq( true, z ), Running_A( 'A', Y, ~sid ) ]->
     [ KeywithErrorA( 'A', Y, ~sid, KA ) ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleA.10
       z     = true
    
    2. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleB.11
       z     = Check_NoEve(KsampleA.10, KsampleB.11)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.12), BA(x.13))), BA(x.13),
                               BB(x.14)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.12), BA(x.13))),
                                              BA(x.13)),
                                       BB(x.14)),
                               BA(x.13), BB(x.14)))
       z     = true
  */

rule (modulo E) Alice_Paramater_Estimation_Eve:
   [
   Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
   Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
   ]
  --[
  Neq( true, Check_NoEve(KsampleA, KsampleB) ),
  EveDetected_A( 'A', Y, ~sid )
  ]->
   [ ]

  /*
  rule (modulo AC) Alice_Paramater_Estimation_Eve:
     [
     Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
     Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
     ]
    --[ Neq( true, z ), EveDetected_A( 'A', Y, ~sid ) ]->
     [ ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleA.8
       z     = true
    
    2. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleB.9
       z     = Check_NoEve(KsampleA.8, KsampleB.9)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.10), BA(x.11))), BA(x.11),
                               BB(x.12)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.10), BA(x.11))),
                                              BA(x.11)),
                                       BB(x.12)),
                               BA(x.11), BB(x.12)))
       z     = true
  */

rule (modulo E) Bob_quantum_phase:
   [ Fr( ~bb ), SessionB( X, 'B', ~sid ), In_QuantumChannel( X, 'B', qA ) ]
  --[ SessionInitB( X, 'B', ~sid ), Create_B( 'A', ~sid ) ]->
   [
   !AuthSession( 'B', ~sid ),
   Measured( X, 'B', ~sid, Measure(qA, BB(~bb)) ),
   BobBasis( X, 'B', ~sid, BB(~bb) ), GetAliceBasis( X, 'B', ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Send_BB:
   [ BobBasis( X, 'B', ~sid, BB ) ]
  --[ Send_BB( 'B', X, BB ) ]->
   [ Out_Auth( 'B', X, BB, 'sift' ), Bob_Sent_BB( 'B', X, ~sid, BB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Receive_BA:
   [ GetAliceBasis( X, 'B', ~sid ), In_Auth( X, 'B', BA, 'sift' ) ]
  --[ Receive_BA( X, 'B', BA ) ]->
   [ Bob_Received_BA( X, 'B', ~sid, BA ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob_SiftB:
   [
   Measured( X, 'B', ~sid, KBraw ), Bob_Sent_BB( 'B', X, ~sid, BB ),
   Bob_Received_BA( X, 'B', ~sid, BA )
   ]
  --[ SiftB( X, 'B', ~sid, Sift_key(KBraw, BA, BB) ) ]->
   [
   SifttedKeyB( X, 'B', ~sid, BA, Sift_key(KBraw, BA, BB) ),
   SampleKeyB( X, 'B', ~sid, Sift_key(KBraw, BA, BB) ),
   GetSampleB( X, 'B', ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Send_SampleB:
   [ SampleKeyB( X, 'B', ~sid, KB ) ]
  --[ Send_SampleB( 'B', X, Sample(KB) ) ]->
   [
   Out_Auth( 'B', X, Sample(KB), 'sample' ),
   Bob_Sent_KsampleB( X, 'B', ~sid, Sample(KB) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Receive_SampleA:
   [ GetSampleB( X, 'B', ~sid ), In_Auth( X, 'B', KsampleA, 'sample' ) ]
  --[ Receive_SampleA( X, 'B', KsampleA ) ]->
   [ Bob_Received_KsampleA( X, 'B', ~sid, KsampleA ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Paramater_Estimation_NoEve:
   [
   SifttedKeyB( X, 'B', ~sid, BA, KB ),
   Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
   Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
   ]
  --[
  Eq( true, Check_NoEve(KsampleA, KsampleB) ), Running_B( X, 'B', ~sid )
  ]->
   [ KeywithErrorB( X, 'B', ~sid, KB ) ]

  /*
  rule (modulo AC) Bob_Paramater_Estimation_NoEve:
     [
     SifttedKeyB( X, 'B', ~sid, BA, KB ),
     Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
     Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
     ]
    --[ Eq( true, z ), Running_B( X, 'B', ~sid ) ]->
     [ KeywithErrorB( X, 'B', ~sid, KB ) ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleA.10
       z     = true
    
    2. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleB.11
       z     = Check_NoEve(KsampleA.10, KsampleB.11)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.12), BA(x.13))), BA(x.13),
                               BB(x.14)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.12), BA(x.13))),
                                              BA(x.13)),
                                       BB(x.14)),
                               BA(x.13), BB(x.14)))
       z     = true
  */

rule (modulo E) Bob_Paramater_Estimation_Eve:
   [
   Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
   Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
   ]
  --[
  Neq( true, Check_NoEve(KsampleA, KsampleB) ),
  EveDetected_B( X, 'B', ~sid )
  ]->
   [ ]

  /*
  rule (modulo AC) Bob_Paramater_Estimation_Eve:
     [
     Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
     Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
     ]
    --[ Neq( true, z ), EveDetected_B( X, 'B', ~sid ) ]->
     [ ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleA.8
       z     = true
    
    2. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleB.9
       z     = Check_NoEve(KsampleA.8, KsampleB.9)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.10), BA(x.11))), BA(x.11),
                               BB(x.12)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.10), BA(x.11))),
                                              BA(x.11)),
                                       BB(x.12)),
                               BA(x.11), BB(x.12)))
       z     = true
  */

rule (modulo E) Alice_Send_FEC:
   [ KeywithErrorA( 'A', Y, ~sid, KA ) ]
  -->
   [
   NKeyA( 'A', Y, ~sid, FEC(GenKey(KA)), GenKey(KA) ),
   Out_Auth( 'A', Y, FEC(GenKey(KA)), 'error' )
   ]

  /*
  rule (modulo AC) Alice_Send_FEC:
     [ KeywithErrorA( 'A', Y, ~sid, KA ) ]
    -->
     [ NKeyA( 'A', Y, ~sid, FEC(z), z ), Out_Auth( 'A', Y, FEC(z), 'error' ) ]
    variants (modulo AC)
    1. KA    = KA.7
       z     = GenKey(KA.7)
    
    2. KA    = Sift_key(Measure(Encode(RawKey(key(Noise(x.9), BA(x.10))),
                                       BA(x.10)),
                                BB(x.11)),
                        BA(x.10), BB(x.11))
       z     = Noise(x.9)
    
    3. KA    = Sift_key(RawKey(key(Noise(x.9), BA(x.10))), BA(x.10),
                        BB(x.11))
       z     = Noise(x.9)
  */

rule (modulo E) Alice_TWEC:
   [ NKeyA( 'A', Y, ~sid, EA, NKAB ), In_Auth( Y, 'A', EB, 'error' ) ]
  --[ CommitKey_A( 'A', Y, ~sid, Correct(NKAB, <EA, EB>) ) ]->
   [ ]

  /*
  rule (modulo AC) Alice_TWEC:
     [ NKeyA( 'A', Y, ~sid, EA, NKAB ), In_Auth( Y, 'A', EB, 'error' ) ]
    --[ CommitKey_A( 'A', Y, ~sid, z ) ]->
     [ ]
    variants (modulo AC)
    1. EA    = EA.12
       EB    = EB.13
       NKAB  = NKAB.14
       z     = Correct(NKAB.14, <EA.12, EB.13>)
    
    2. EA    = FEC(Noise(z.10))
       EB    = REC(Noise(z.10))
       NKAB  = Noise(z.10)
       z     = z.10
  */

rule (modulo E) Bob_Send_REC:
   [ KeywithErrorB( X, 'B', ~sid, KB ) ]
  -->
   [
   NKeyA( X, 'B', ~sid, REC(GenKey(KB)), GenKey(KB) ),
   Out_Auth( 'B', X, REC(GenKey(KB)), 'error' )
   ]

  /*
  rule (modulo AC) Bob_Send_REC:
     [ KeywithErrorB( X, 'B', ~sid, KB ) ]
    -->
     [ NKeyA( X, 'B', ~sid, REC(z), z ), Out_Auth( 'B', X, REC(z), 'error' ) ]
    variants (modulo AC)
    1. KB    = KB.7
       z     = GenKey(KB.7)
    
    2. KB    = Sift_key(Measure(Encode(RawKey(key(Noise(x.9), BA(x.10))),
                                       BA(x.10)),
                                BB(x.11)),
                        BA(x.10), BB(x.11))
       z     = Noise(x.9)
    
    3. KB    = Sift_key(RawKey(key(Noise(x.9), BA(x.10))), BA(x.10),
                        BB(x.11))
       z     = Noise(x.9)
  */

rule (modulo E) Bob_TWEC:
   [ NKeyA( X, 'B', ~sid, EB, NKAB ), In_Auth( X, 'B', EA, 'error' ) ]
  --[ CommitKey_B( X, 'B', ~sid, Correct(NKAB, <EA, EB>) ) ]->
   [ ]

  /*
  rule (modulo AC) Bob_TWEC:
     [ NKeyA( X, 'B', ~sid, EB, NKAB ), In_Auth( X, 'B', EA, 'error' ) ]
    --[ CommitKey_B( X, 'B', ~sid, z ) ]->
     [ ]
    variants (modulo AC)
    1. EA    = EA.12
       EB    = EB.13
       NKAB  = NKAB.14
       z     = Correct(NKAB.14, <EA.12, EB.13>)
    
    2. EA    = FEC(Noise(z.10))
       EB    = REC(Noise(z.10))
       NKAB  = Noise(z.10)
       z     = z.10
  */

lemma Executability [sources]:
  exists-trace
  "∃ A B sid Kab #i #j.
    (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
    (CommitKey_B( A, B, sid, Kab ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ A B sid Kab #i #j.
  (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
  (CommitKey_B( A, B, sid, Kab ) @ #j)"
*/
induction
  case non_empty_trace
  simplify
  solve( (last(#j))  ∥ (last(#i)) )
    case case_1
    solve( NKeyA( 'A', 'B', ~sid, EA, NKAB ) ▶₀ #i )
      case Alice_Send_FEC
      solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
        case ChanIn_Auth_case_2
        solve( NKeyA( 'A', 'B', ~sid, EB, NKAB.1 ) ▶₀ #j )
          case Bob_Send_REC
          solve( In_Auth( 'A', 'B', EA, 'error' ) ▶₁ #j )
            case ChanIn_Auth
            solve( splitEqs(0) )
              case split
              solve( splitEqs(2) )
                case split_case_1
                solve( splitEqs(4) )
                  case split_case_2
                  solve( !KU( key(Noise(~kab), BA(x.1)) ) @ #vk.17 )
                    case QChan_Adv_Measure
                    solve( !KU( BA(~ba) ) @ #vk.18 )
                      case ChanOut_Auth_case_1
                      solve( In_Auth( 'B', 'A',
                                      Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                                                     BA(~ba)),
                                                              BB(x)),
                                                      BA(~ba), BB(x))),
                                      'sample'
                             ) ▶₁ #vr.4 )
                        case ChanIn_Auth
                        solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.7 )
                          case ChanIn_Auth
                          solve( In_Auth( 'A', 'B',
                                          Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba),
                                                          BB(~bb))),
                                          'sample'
                                 ) ▶₁ #vr.17 )
                            case ChanIn_Auth
                            solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.19 )
                              case ChanIn_Auth
                              solve( !KU( mac(REC(Noise(~kab)), ~sid) ) @ #vk.24 )
                                case ChanOut_Auth_case_2
                                solve( !KU( mac(FEC(Noise(~kab)), ~sid) ) @ #vk.29 )
                                  case ChanOut_Auth_case_2
                                  solve( !KU( mac(Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                                            BA(~ba))),
                                                                                 BA(~ba)),
                                                                          BB(~bb)),
                                                                  BA(~ba), BB(~bb))),
                                                  ~sid)
                                         ) @ #vk.33 )
                                    case ChanOut_Auth_case_2
                                    solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.40 )
                                      case ChanOut_Auth_case_2
                                      solve( !KU( mac(Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                                      BA(~ba), BB(~bb))),
                                                      ~sid)
                                             ) @ #vk.44 )
                                        case ChanOut_Auth_case_2
                                        solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.45 )
                                          case ChanOut_Auth_case_2
                                          solve( !KU( REC(Noise(~kab)) ) @ #vk.36 )
                                            case ChanOut_Auth_case_1
                                            solve( !KU( FEC(Noise(~kab)) ) @ #vk.40 )
                                              case ChanOut_Auth_case_1
                                              solve( !KU( Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                                                    BA(~ba))),
                                                                                         BA(~ba)),
                                                                                  BB(~bb)),
                                                                          BA(~ba), BB(~bb)))
                                                     ) @ #vk.41 )
                                                case ChanOut_Auth_case_1
                                                solve( !KU( BB(~bb) ) @ #vk.43 )
                                                  case ChanOut_Auth_case_1
                                                  solve( !KU( Sample(Sift_key(RawKey(key(Noise(~kab),
                                                                                         BA(~ba))),
                                                                              BA(~ba), BB(~bb)))
                                                         ) @ #vk.45 )
                                                    case ChanOut_Auth_case_1
                                                    SOLVED // trace found
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma messsage_authenticiation [sources]:
  all-traces
  "∀ A B msg #i.
    (AChanIn( A, B, msg ) @ #i) ⇒ (∃ #k. AChanOut( A, msg ) @ #k)"
/*
guarded formula characterizing all counter-examples:
"∃ A B msg #i.
  (AChanIn( A, B, msg ) @ #i) ∧ ∀ #k. (AChanOut( A, msg ) @ #k) ⇒ ⊥"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #k. (AChanOut( A, <msg, type> ) @ #k) ∧ ¬(last(#k))) )
    case case_1
    solve( !AuthSession( B, key_roleB ) ▶₀ #i )
      case Alice_quantum_phase
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_1
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_1
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_2
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_3
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_4
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_5
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_6
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_2
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_1
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_2
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_3
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_4
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_5
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_6
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_3
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_1
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_2
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_3
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_4
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_5
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_6
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma secret_key_A:
  all-traces
  "∀ A B sid Kab #init #i #j.
    (((SessionInitA( A, B, sid ) @ #init) ∧
      (CommitKey_A( A, B, sid, Kab ) @ #i)) ∧
     (K( Kab ) @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ A B sid Kab #init #i #j.
  (SessionInitA( A, B, sid ) @ #init) ∧
  (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
  (K( Kab ) @ #j)"
*/
simplify
solve( SessionA( 'A', B, ~sid ) ▶₂ #init )
  case Setup
  solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
    case Alice_Send_FEC
    solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
      case ChanIn_Auth_case_1
      solve( splitEqs(2) )
        case split_case_1
        solve( splitEqs(3) )
          case split_case_1
          solve( !KU( Correct(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                              BA(~ba), BB)),
                              <FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba), BB))), 
                               FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba), BB)))>)
                 ) @ #vk )
            case c_Correct
            solve( !KU( GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba),
                                        BB))
                   ) @ #vk.11 )
              case c_GenKey
              solve( !KU( Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba), BB)
                     ) @ #vk.12 )
                case c_Sift_key
                solve( !KU( RawKey(key(Noise(~kab), BA(~ba))) ) @ #vk.13 )
                  case c_RawKey
                  solve( !KU( BA(~ba) ) @ #vk.14 )
                    case ChanOut_Auth_case_1
                    solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.16 )
                      case QChan_Adv_Measure
                      solve( In_Auth( 'A', 'A',
                                      Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba), BB)),
                                      'sample'
                             ) ▶₁ #vr.5 )
                        case ChanIn_Auth
                        solve( In_Auth( 'A', 'A', BB, 'sift' ) ▶₁ #vr.7 )
                          case ChanIn_Auth
                          solve( !KU( mac(FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                              BA(~ba), BA(~ba)))),
                                          ~sid)
                                 ) @ #vk.19 )
                            case ChanOut_Auth
                            solve( !KU( mac(Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                            BA(~ba), BA(~ba))),
                                            ~sid)
                                   ) @ #vk.24 )
                              case ChanOut_Auth
                              solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.27 )
                                case ChanOut_Auth
                                solve( !KU( FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                                BA(~ba), BA(~ba))))
                                       ) @ #vk.21 )
                                  case ChanOut_Auth_case_1
                                  solve( !KU( Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba),
                                                              BA(~ba)))
                                         ) @ #vk.26 )
                                    case ChanOut_Auth_case_1
                                    SOLVED // trace found
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma secret_key_B:
  all-traces
  "∀ A B sid Kab #init #i #j.
    (((SessionInitB( A, B, sid ) @ #init) ∧
      (CommitKey_B( A, B, sid, Kab ) @ #i)) ∧
     (K( Kab ) @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ A B sid Kab #init #i #j.
  (SessionInitB( A, B, sid ) @ #init) ∧
  (CommitKey_B( A, B, sid, Kab ) @ #i) ∧
  (K( Kab ) @ #j)"
*/
simplify
solve( SessionB( A, 'B', ~sid ) ▶₁ #init )
  case Setup
  solve( In_QuantumChannel( A, 'B', qA ) ▶₂ #init )
    case QChan_Create_State
    solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
      case Alice_Send_FEC
      solve( In_Auth( 'A', 'B', EA, 'error' ) ▶₁ #i )
        case ChanIn_Auth
        solve( splitEqs(2) )
          case split_case_2
          solve( !KU( Correct(Noise(~kab), <FEC(Noise(~kab)), FEC(Noise(~kab))>)
                 ) @ #vk )
            case c_Correct
            solve( !KU( Noise(~kab) ) @ #vk.17 )
              case QChan_Adv_Measure_case_1
              solve( !KU( BA(~ba) ) @ #vk.19 )
                case ChanOut_Auth_case_1
                solve( In_Auth( 'B', 'A',
                                Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                                               BA(~ba)),
                                                        BB(x)),
                                                BA(~ba), BB(x))),
                                'sample'
                       ) ▶₁ #vr.6 )
                  case ChanIn_Auth
                  solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.13 )
                    case c_key
                    solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.9 )
                      case ChanIn_Auth
                      solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.24 )
                        case ChanIn_Auth
                        solve( !KU( BB(bb.1) ) @ #vk.25 )
                          case c_BB
                          solve( !KU( mac(FEC(Noise(~kab)), ~sid) ) @ #vk.24 )
                            case ChanOut_Auth_case_3
                            solve( !KU( mac(Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                                      BA(~ba))),
                                                                           BA(~ba)),
                                                                    BB(~bb)),
                                                            BA(~ba), BB(~bb))),
                                            ~sid)
                                   ) @ #vk.29 )
                              case ChanOut_Auth_case_3
                              solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.34 )
                                case ChanOut_Auth_case_3
                                solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.37 )
                                  case ChanOut_Auth_case_3
                                  solve( !KU( FEC(Noise(~kab)) ) @ #vk.29 )
                                    case ChanOut_Auth_case_1
                                    solve( !KU( Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                                          BA(~ba))),
                                                                               BA(~ba)),
                                                                        BB(~bb)),
                                                                BA(~ba), BB(~bb)))
                                           ) @ #vk.34 )
                                      case ChanOut_Auth_case_1
                                      solve( !KU( BB(~bb) ) @ #vk.36 )
                                        case ChanOut_Auth_case_1
                                        SOLVED // trace found
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma aliveness_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ #j. Create_B( 'A', sid ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ #j. (Create_B( 'A', sid ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
  case Alice_Send_FEC
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    solve( splitEqs(1) )
      case split_case_1
      solve( splitEqs(2) )
        case split_case_1
        solve( In_Auth( 'A', 'A',
                        Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba), BB)),
                        'sample'
               ) ▶₁ #vr.4 )
          case ChanIn_Auth
          solve( In_Auth( 'A', 'A', BB, 'sift' ) ▶₁ #vr.7 )
            case ChanIn_Auth
            solve( !KU( mac(FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                BA(~ba), BA(~ba)))),
                            ~sid)
                   ) @ #vk.11 )
              case ChanOut_Auth
              solve( !KU( mac(Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                              BA(~ba), BA(~ba))),
                              ~sid)
                     ) @ #vk.16 )
                case ChanOut_Auth
                solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.21 )
                  case ChanOut_Auth
                  solve( !KU( FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                  BA(~ba), BA(~ba))))
                         ) @ #vk.14 )
                    case ChanOut_Auth_case_1
                    solve( !KU( Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba),
                                                BA(~ba)))
                           ) @ #vk.18 )
                      case ChanOut_Auth_case_1
                      solve( !KU( BA(~ba) ) @ #vk.21 )
                        case ChanOut_Auth_case_1
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma aliveness_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ #j. (Create_A( 'B', sid ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ #j. (Create_A( 'B', sid ) @ #j) ⇒ ¬(#j < #i)"
*/
simplify
solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
  case Bob_Send_REC_case_1
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_2
    solve( In_Auth( 'B', 'B',
                    Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)), BB(~bb)),
                                    BA, BB(~bb))),
                    'sample'
           ) ▶₁ #vr.4 )
      case ChanIn_Auth
      solve( In_Auth( 'B', 'B', BA, 'sift' ) ▶₁ #vr.7 )
        case ChanIn_Auth
        solve( !KU( mac(REC(GenKey(Sift_key(Measure(Encode(key(Noise(KE),
                                                               BA(ba)),
                                                           BA(ba)),
                                                    BB(~bb)),
                                            BB(~bb), BB(~bb)))),
                        ~sid)
               ) @ #vk.16 )
          case ChanOut_Auth
          solve( !KU( mac(Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                         BA(ba)),
                                                  BB(~bb)),
                                          BB(~bb), BB(~bb))),
                          ~sid)
                 ) @ #vk.21 )
            case ChanOut_Auth
            solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.26 )
              case ChanOut_Auth
              solve( !KU( REC(GenKey(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                             BA(ba)),
                                                      BB(~bb)),
                                              BB(~bb), BB(~bb))))
                     ) @ #vk.19 )
                case ChanOut_Auth_case_1
                solve( !KU( Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                           BA(ba)),
                                                    BB(~bb)),
                                            BB(~bb), BB(~bb)))
                       ) @ #vk.23 )
                  case ChanOut_Auth_case_1
                  solve( !KU( BB(~bb) ) @ #vk.26 )
                    case ChanOut_Auth_case_1
                    SOLVED // trace found
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma weak_agreement_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ sid2 #j. Running_B( 'A', B, sid2 ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ sid2 #j. (Running_B( 'A', B, sid2 ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
  case Alice_Send_FEC
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    solve( splitEqs(1) )
      case split_case_1
      solve( splitEqs(2) )
        case split_case_1
        solve( In_Auth( 'A', 'A',
                        Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba), BB)),
                        'sample'
               ) ▶₁ #vr.4 )
          case ChanIn_Auth
          solve( In_Auth( 'A', 'A', BB, 'sift' ) ▶₁ #vr.7 )
            case ChanIn_Auth
            solve( !KU( mac(FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                BA(~ba), BA(~ba)))),
                            ~sid)
                   ) @ #vk.11 )
              case ChanOut_Auth
              solve( !KU( mac(Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                              BA(~ba), BA(~ba))),
                              ~sid)
                     ) @ #vk.16 )
                case ChanOut_Auth
                solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.21 )
                  case ChanOut_Auth
                  solve( !KU( FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                  BA(~ba), BA(~ba))))
                         ) @ #vk.14 )
                    case ChanOut_Auth_case_1
                    solve( !KU( Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba),
                                                BA(~ba)))
                           ) @ #vk.18 )
                      case ChanOut_Auth_case_1
                      solve( !KU( BA(~ba) ) @ #vk.21 )
                        case ChanOut_Auth_case_1
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma weak_agreement_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ sid2 #j. Running_A( A, 'B', sid2 ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ sid2 #j. (Running_A( A, 'B', sid2 ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
  case Bob_Send_REC_case_1
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_2
    solve( In_Auth( 'B', 'B',
                    Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)), BB(~bb)),
                                    BA, BB(~bb))),
                    'sample'
           ) ▶₁ #vr.4 )
      case ChanIn_Auth
      solve( In_Auth( 'B', 'B', BA, 'sift' ) ▶₁ #vr.7 )
        case ChanIn_Auth
        solve( !KU( mac(REC(GenKey(Sift_key(Measure(Encode(key(Noise(KE),
                                                               BA(ba)),
                                                           BA(ba)),
                                                    BB(~bb)),
                                            BB(~bb), BB(~bb)))),
                        ~sid)
               ) @ #vk.16 )
          case ChanOut_Auth
          solve( !KU( mac(Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                         BA(ba)),
                                                  BB(~bb)),
                                          BB(~bb), BB(~bb))),
                          ~sid)
                 ) @ #vk.21 )
            case ChanOut_Auth
            solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.26 )
              case ChanOut_Auth
              solve( !KU( REC(GenKey(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                             BA(ba)),
                                                      BB(~bb)),
                                              BB(~bb), BB(~bb))))
                     ) @ #vk.19 )
                case ChanOut_Auth_case_1
                solve( !KU( Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                           BA(ba)),
                                                    BB(~bb)),
                                            BB(~bb), BB(~bb)))
                       ) @ #vk.23 )
                  case ChanOut_Auth_case_1
                  solve( !KU( BB(~bb) ) @ #vk.26 )
                    case ChanOut_Auth_case_1
                    SOLVED // trace found
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ #j. CommitKey_B( 'A', B, sid, kab ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ #j. (CommitKey_B( 'A', B, sid, kab ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
  case Alice_Send_FEC
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    solve( splitEqs(1) )
      case split_case_1
      solve( splitEqs(2) )
        case split_case_1
        solve( In_Auth( 'A', 'A',
                        Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba), BB)),
                        'sample'
               ) ▶₁ #vr.4 )
          case ChanIn_Auth
          solve( In_Auth( 'A', 'A', BB, 'sift' ) ▶₁ #vr.7 )
            case ChanIn_Auth
            solve( !KU( mac(FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                BA(~ba), BA(~ba)))),
                            ~sid)
                   ) @ #vk.11 )
              case ChanOut_Auth
              solve( !KU( mac(Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                              BA(~ba), BA(~ba))),
                              ~sid)
                     ) @ #vk.16 )
                case ChanOut_Auth
                solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.21 )
                  case ChanOut_Auth
                  solve( !KU( FEC(GenKey(Sift_key(RawKey(key(Noise(~kab), BA(~ba))),
                                                  BA(~ba), BA(~ba))))
                         ) @ #vk.14 )
                    case ChanOut_Auth_case_1
                    solve( !KU( Sample(Sift_key(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba),
                                                BA(~ba)))
                           ) @ #vk.18 )
                      case ChanOut_Auth_case_1
                      solve( !KU( BA(~ba) ) @ #vk.21 )
                        case ChanOut_Auth_case_1
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ #j. CommitKey_A( A, 'B', sid, kab ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ #j. (CommitKey_A( A, 'B', sid, kab ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
  case Alice_Send_FEC
  solve( In_Auth( 'A', 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_3
    solve( splitEqs(1) )
      case split_case_2
      solve( In_Auth( 'B', 'A',
                      Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                                     BA(~ba)),
                                              BB(x)),
                                      BA(~ba), BB(x))),
                      'sample'
             ) ▶₁ #vr.4 )
        case ChanIn_Auth
        solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.7 )
          case ChanIn_Auth
          solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.19 )
            case ChanIn_Auth
            solve( !KU( mac(FEC(Noise(~kab)), ~sid) ) @ #vk.14 )
              case ChanOut_Auth
              solve( !KU( mac(Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                        BA(~ba))),
                                                             BA(~ba)),
                                                      BB(~bb)),
                                              BA(~ba), BB(~bb))),
                              ~sid)
                     ) @ #vk.19 )
                case ChanOut_Auth
                solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.24 )
                  case ChanOut_Auth
                  solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.29 )
                    case ChanOut_Auth
                    solve( !KU( FEC(Noise(~kab)) ) @ #vk.20 )
                      case ChanOut_Auth_case_1
                      solve( !KU( Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                            BA(~ba))),
                                                                 BA(~ba)),
                                                          BB(~bb)),
                                                  BA(~ba), BB(~bb)))
                             ) @ #vk.24 )
                        case ChanOut_Auth_case_1
                        solve( !KU( BB(~bb) ) @ #vk.27 )
                          case ChanOut_Auth_case_1
                          solve( !KU( BA(~ba) ) @ #vk.29 )
                            case ChanOut_Auth_case_1
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed









































/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.8.0
Maude version 3.2.1
Git revision: f172d7f00b1485446a1e7a42dc14623c2189cc42, branch: master
Compiled at: 2023-09-01 08:49:23.916032222 UTC
*/

end==============================================================================
summary of summaries:

analyzed: ./output/PM_Adv_Network_SeqA_TWEC.spthy

  output:          ./output/PM_Adv_Network_SeqA_TWEC.proof
  processing time: 479.02s
  
  Executability (exists-trace): verified (28 steps)
  messsage_authenticiation (all-traces): verified (40 steps)
  secret_key_A (all-traces): falsified - found trace (20 steps)
  secret_key_B (all-traces): falsified - found trace (22 steps)
  aliveness_A (all-traces): falsified - found trace (14 steps)
  aliveness_B (all-traces): falsified - found trace (12 steps)
  weak_agreement_A (all-traces): falsified - found trace (14 steps)
  weak_agreement_B (all-traces): falsified - found trace (12 steps)
  noninjectiveagreement_A (all-traces): falsified - found trace (14 steps)
  noninjectiveagreement_B (all-traces): falsified - found trace (16 steps)

==============================================================================


