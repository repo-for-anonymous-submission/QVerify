theory PM_Adv_Network_SeqB_REC_protocol begin

// Function signature and definition of the equational theory E

functions: BA/1, BB/1, Check_NoEve/2[private,destructor], Correct/2,
           Encode/2, GenKey/1, Measure/2[private,destructor], Noise/1, REC/1,
           RawKey/1, Sample/1, Sift_key/3, fst/1, key/2, mac/2[private,destructor],
           pair/2, snd/1, true/0, verifymac/2
equations:
    Check_NoEve(Sample_key, Sample_key) = true,
    Check_NoEve(Sample(Sift_key(RawKey(key(Noise(kab), BA(ba))), BA(ba),
                                BB(bb))),
                Sample(Sift_key(Measure(Encode(RawKey(key(Noise(kab), BA(ba))), BA(ba)),
                                        BB(bb)),
                                BA(ba), BB(bb))))
  = true,
    Correct(Noise(kab), REC(Noise(kab))) = kab,
    GenKey(Sift_key(Measure(Encode(RawKey(key(Noise(kab), BA(ba))), BA(ba)),
                            BB(bb)),
                    BA(ba), BB(bb)))
  = Noise(kab),
    GenKey(Sift_key(RawKey(key(Noise(kab), BA(ba))), BA(ba), BB(bb)))
  = Noise(kab),
    Measure(Encode(RawKey(key(Noise(kab), BA(ba))), BA(ba)), BA(ba))
  = key(Noise(kab), BA(ba)),
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verifymac(mac(msg, key), key) = msg





restriction Eq_checks_succeed:
  "∀ x y #j. (Eq( x, y ) @ #j) ⇒ (x = y)"
  // safety formula

restriction Neq_checks_succeed:
  "∀ x #j. (Neq( x, x ) @ #j) ⇒ (⊥)"
  // safety formula

restriction Basis_Announcement_order_Sequential_Bob_First:
  "∀ A B BA BB #sBA #sBB #rBA #rBB.
    ((((Send_BA( A, B, BA ) @ #sBA) ∧ (Receive_BA( A, B, BA ) @ #rBA)) ∧
      (Send_BB( B, A, BB ) @ #sBB)) ∧
     (Receive_BB( B, A, BB ) @ #rBB)) ⇒
    (((#sBB < #rBB) ∧ (#rBB < #sBA)) ∧ (#sBA < #rBA))"
  // safety formula

restriction OnlyOnce:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Setup:
   [ In( <X, Y> ), Fr( ~sid ) ]
  --[ OnlyOnce( ) ]->
   [ SessionA( X, Y, ~sid ), SessionB( X, Y, ~sid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Out:
   [ Out_QuantumChannel( X, Y, qA ) ]
  --[ EveKnowns( qA ), QChanOut( X, Y, qA ) ]->
   [ Quantum( qA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Adv_Measure:
   [ In( BA ), Quantum( qA ) ]
  --[ EveForgets( qA ) ]->
   [ Out( Measure(qA, BA) ) ]

  /*
  rule (modulo AC) QChan_Adv_Measure:
     [ In( BA ), Quantum( qA ) ] --[ EveForgets( qA ) ]-> [ Out( z ) ]
    variants (modulo AC)
    1. BA    = BA.4
       qA    = qA.4
       z     = Measure(qA.4, BA.4)
    
    2. BA    = BA(x.4)
       qA    = Encode(RawKey(key(Noise(x.5), BA(x.4))), BA(x.4))
       z     = key(Noise(x.5), BA(x.4))
  */

rule (modulo E) QChan_Create_State_new:
   [ In( <X, Y, KE, ba> ) ]
  -->
   [ In_QuantumChannel( X, Y, Encode(key(Noise(KE), BA(ba)), BA(ba)) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Create_State:
   [ In( <X, Y, KE, BA> ) ]
  -->
   [ In_QuantumChannel( X, Y, Encode(RawKey(KE), BA) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Chan_In_Forward:
   [ Quantum( qA ), In( <X, Y> ) ]
  --[ EveForgets( qA ), QChanIn( X, Y, qA ) ]->
   [ In_QuantumChannel( X, Y, qA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ChanOut_Auth:
   [ !AuthSession( roleA, key_roleA ), Out_Auth( roleA, roleB, msg, type ) ]
  --[ AChanOut( roleA, <msg, type> ) ]->
   [
   !Auth( roleA, msg, mac(msg, key_roleA), type ),
   Out( <roleA, roleB, msg, mac(msg, key_roleA), type> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ChanIn_Auth:
   [
   !AuthSession( roleB, key_roleB ), !Auth( roleA, msg, tag, type ),
   In( <roleA, roleB, msg, tag, type> )
   ]
  --[
  Eq( msg, verifymac(tag, key_roleB) ),
  AChanIn( roleA, roleB, <msg, type> )
  ]->
   [ In_Auth( roleA, roleB, msg, type ) ]

  /*
  rule (modulo AC) ChanIn_Auth:
     [
     !AuthSession( roleB, key_roleB ), !Auth( roleA, msg, tag, type ),
     In( <roleA, roleB, msg, tag, type> )
     ]
    --[ Eq( msg, z ), AChanIn( roleA, roleB, <msg, type> ) ]->
     [ In_Auth( roleA, roleB, msg, type ) ]
    variants (modulo AC)
    1. key_roleB
             = key_roleB.8
       tag   = tag.8
       z     = verifymac(tag.8, key_roleB.8)
    
    2. key_roleB
             = x.8
       tag   = mac(x.12, x.8)
       z     = x.12
  */

rule (modulo E) Alice_quantum_phase:
   [ Fr( ~ba ), Fr( ~kab ), SessionA( 'A', Y, ~sid ) ]
  --[ SessionInitA( 'A', Y, ~sid ), Create_A( 'B', ~sid ) ]->
   [
   !AuthSession( 'A', ~sid ),
   Out_QuantumChannel( 'A', Y,
                       Encode(RawKey(key(Noise(~kab), BA(~ba))), BA(~ba))
   ),
   Encoded( 'A', Y, ~sid, RawKey(key(Noise(~kab), BA(~ba))) ),
   AliceBasis( 'A', Y, ~sid, BA(~ba) ), GetBobBasis( 'A', Y, ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Send_BA:
   [ AliceBasis( 'A', Y, ~sid, BA ) ]
  --[ Send_BA( 'A', Y, BA ) ]->
   [ Out_Auth( 'A', Y, BA, 'sift' ), Alice_Sent_BA( 'A', Y, ~sid, BA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Receive_BB:
   [ GetBobBasis( 'A', Y, ~sid ), In_Auth( Y, 'A', BB, 'sift' ) ]
  --[ Receive_BB( Y, 'A', BB ) ]->
   [ Alice_Received_BB( 'A', Y, ~sid, BB ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice_SiftA:
   [
   Encoded( 'A', Y, ~sid, KAraw ), Alice_Sent_BA( 'A', Y, ~sid, BA ),
   Alice_Received_BB( 'A', Y, ~sid, BB )
   ]
  --[ SiftA( 'A', Y, ~sid, Sift_key(KAraw, BA, BB) ) ]->
   [
   SifttedKeyA( 'A', Y, ~sid, BB, Sift_key(KAraw, BA, BB) ),
   SampleKeyA( 'A', Y, ~sid, Sift_key(KAraw, BA, BB) ),
   GetSampleA( 'A', Y, ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Send_SampleA:
   [ SampleKeyA( 'A', Y, ~sid, KA ) ]
  --[ Send_SampleA( 'A', Y, Sample(KA) ) ]->
   [
   Out_Auth( 'A', Y, Sample(KA), 'sample' ),
   Alice_Sent_KsampleA( 'A', Y, ~sid, Sample(KA) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Receive_SampleB:
   [ GetSampleA( 'A', Y, ~sid ), In_Auth( Y, 'A', KsampleB, 'sample' ) ]
  --[ Receive_SampleB( Y, 'A', KsampleB ) ]->
   [ Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Paramater_Estimation_NoEve:
   [
   SifttedKeyA( 'A', Y, ~sid, BB, KA ),
   Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
   Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
   ]
  --[
  Eq( true, Check_NoEve(KsampleA, KsampleB) ), Running_A( 'A', Y, ~sid )
  ]->
   [ KeywithErrorA( 'A', Y, ~sid, KA ) ]

  /*
  rule (modulo AC) Alice_Paramater_Estimation_NoEve:
     [
     SifttedKeyA( 'A', Y, ~sid, BB, KA ),
     Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
     Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
     ]
    --[ Eq( true, z ), Running_A( 'A', Y, ~sid ) ]->
     [ KeywithErrorA( 'A', Y, ~sid, KA ) ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleA.10
       z     = true
    
    2. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleB.11
       z     = Check_NoEve(KsampleA.10, KsampleB.11)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.12), BA(x.13))), BA(x.13),
                               BB(x.14)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.12), BA(x.13))),
                                              BA(x.13)),
                                       BB(x.14)),
                               BA(x.13), BB(x.14)))
       z     = true
  */

rule (modulo E) Alice_Paramater_Estimation_Eve:
   [
   Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
   Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
   ]
  --[
  Neq( true, Check_NoEve(KsampleA, KsampleB) ),
  EveDetected_A( 'A', Y, ~sid )
  ]->
   [ ]

  /*
  rule (modulo AC) Alice_Paramater_Estimation_Eve:
     [
     Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
     Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
     ]
    --[ Neq( true, z ), EveDetected_A( 'A', Y, ~sid ) ]->
     [ ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleA.8
       z     = true
    
    2. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleB.9
       z     = Check_NoEve(KsampleA.8, KsampleB.9)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.10), BA(x.11))), BA(x.11),
                               BB(x.12)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.10), BA(x.11))),
                                              BA(x.11)),
                                       BB(x.12)),
                               BA(x.11), BB(x.12)))
       z     = true
  */

rule (modulo E) Bob_quantum_phase:
   [ Fr( ~bb ), SessionB( X, 'B', ~sid ), In_QuantumChannel( X, 'B', qA ) ]
  --[ SessionInitB( X, 'B', ~sid ), Create_B( 'A', ~sid ) ]->
   [
   !AuthSession( 'B', ~sid ),
   Measured( X, 'B', ~sid, Measure(qA, BB(~bb)) ),
   BobBasis( X, 'B', ~sid, BB(~bb) ), GetAliceBasis( X, 'B', ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Send_BB:
   [ BobBasis( X, 'B', ~sid, BB ) ]
  --[ Send_BB( 'B', X, BB ) ]->
   [ Out_Auth( 'B', X, BB, 'sift' ), Bob_Sent_BB( 'B', X, ~sid, BB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Receive_BA:
   [ GetAliceBasis( X, 'B', ~sid ), In_Auth( X, 'B', BA, 'sift' ) ]
  --[ Receive_BA( X, 'B', BA ) ]->
   [ Bob_Received_BA( X, 'B', ~sid, BA ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob_SiftB:
   [
   Measured( X, 'B', ~sid, KBraw ), Bob_Sent_BB( 'B', X, ~sid, BB ),
   Bob_Received_BA( X, 'B', ~sid, BA )
   ]
  --[ SiftB( X, 'B', ~sid, Sift_key(KBraw, BA, BB) ) ]->
   [
   SifttedKeyB( X, 'B', ~sid, BA, Sift_key(KBraw, BA, BB) ),
   SampleKeyB( X, 'B', ~sid, Sift_key(KBraw, BA, BB) ),
   GetSampleB( X, 'B', ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Send_SampleB:
   [ SampleKeyB( X, 'B', ~sid, KB ) ]
  --[ Send_SampleB( 'B', X, Sample(KB) ) ]->
   [
   Out_Auth( 'B', X, Sample(KB), 'sample' ),
   Bob_Sent_KsampleB( X, 'B', ~sid, Sample(KB) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Receive_SampleA:
   [ GetSampleB( X, 'B', ~sid ), In_Auth( X, 'B', KsampleA, 'sample' ) ]
  --[ Receive_SampleA( X, 'B', KsampleA ) ]->
   [ Bob_Received_KsampleA( X, 'B', ~sid, KsampleA ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Paramater_Estimation_NoEve:
   [
   SifttedKeyB( X, 'B', ~sid, BA, KB ),
   Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
   Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
   ]
  --[
  Eq( true, Check_NoEve(KsampleA, KsampleB) ), Running_B( X, 'B', ~sid )
  ]->
   [ KeywithErrorB( X, 'B', ~sid, KB ) ]

  /*
  rule (modulo AC) Bob_Paramater_Estimation_NoEve:
     [
     SifttedKeyB( X, 'B', ~sid, BA, KB ),
     Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
     Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
     ]
    --[ Eq( true, z ), Running_B( X, 'B', ~sid ) ]->
     [ KeywithErrorB( X, 'B', ~sid, KB ) ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleA.10
       z     = true
    
    2. KsampleA
             = KsampleA.10
       KsampleB
             = KsampleB.11
       z     = Check_NoEve(KsampleA.10, KsampleB.11)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.12), BA(x.13))), BA(x.13),
                               BB(x.14)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.12), BA(x.13))),
                                              BA(x.13)),
                                       BB(x.14)),
                               BA(x.13), BB(x.14)))
       z     = true
  */

rule (modulo E) Bob_Paramater_Estimation_Eve:
   [
   Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
   Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
   ]
  --[
  Neq( true, Check_NoEve(KsampleA, KsampleB) ),
  EveDetected_B( X, 'B', ~sid )
  ]->
   [ ]

  /*
  rule (modulo AC) Bob_Paramater_Estimation_Eve:
     [
     Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
     Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
     ]
    --[ Neq( true, z ), EveDetected_B( X, 'B', ~sid ) ]->
     [ ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleA.8
       z     = true
    
    2. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleB.9
       z     = Check_NoEve(KsampleA.8, KsampleB.9)
    
    3. KsampleA
             = Sample(Sift_key(RawKey(key(Noise(x.10), BA(x.11))), BA(x.11),
                               BB(x.12)))
       KsampleB
             = Sample(Sift_key(Measure(Encode(RawKey(key(Noise(x.10), BA(x.11))),
                                              BA(x.11)),
                                       BB(x.12)),
                               BA(x.11), BB(x.12)))
       z     = true
  */

rule (modulo E) Alice_REC:
   [ KeywithErrorA( 'A', Y, ~sid, KA ), In_Auth( Y, 'A', EB, 'error' ) ]
  --[ CommitKey_A( 'A', Y, ~sid, Correct(GenKey(KA), EB) ) ]->
   [ ]

  /*
  rule (modulo AC) Alice_REC:
     [ KeywithErrorA( 'A', Y, ~sid, KA ), In_Auth( Y, 'A', EB, 'error' ) ]
    --[ CommitKey_A( 'A', Y, ~sid, z ) ]->
     [ ]
    variants (modulo AC)
    1. EB    = EB.10
       KA    = KA.11
       z     = Correct(GenKey(KA.11), EB.10)
    
    2. EB    = EB.17
       KA    = Sift_key(Measure(Encode(RawKey(key(Noise(x.29), BA(x.30))),
                                       BA(x.30)),
                                BB(x.31)),
                        BA(x.30), BB(x.31))
       z     = Correct(Noise(x.29), EB.17)
    
    3. EB    = EB.17
       KA    = Sift_key(RawKey(key(Noise(x.29), BA(x.30))), BA(x.30), BB(x.31))
       z     = Correct(Noise(x.29), EB.17)
    
    4. EB    = REC(Noise(z.12))
       KA    = Sift_key(Measure(Encode(RawKey(key(Noise(z.12), BA(x.15))),
                                       BA(x.15)),
                                BB(x.16)),
                        BA(x.15), BB(x.16))
       z     = z.12
    
    5. EB    = REC(Noise(z.12))
       KA    = Sift_key(RawKey(key(Noise(z.12), BA(x.15))), BA(x.15), BB(x.16))
       z     = z.12
  */

rule (modulo E) Bob_REC:
   [ KeywithErrorB( X, 'B', ~sid, KB ) ]
  --[ CommitKey_B( X, 'B', ~sid, Correct(GenKey(KB), REC(GenKey(KB))) ) ]->
   [ Out_Auth( 'B', X, REC(GenKey(KB)), 'error' ) ]

  /*
  rule (modulo AC) Bob_REC:
     [ KeywithErrorB( X, 'B', ~sid, KB ) ]
    --[ CommitKey_B( X, 'B', ~sid, z.1 ) ]->
     [ Out_Auth( 'B', X, REC(z), 'error' ) ]
    variants (modulo AC)
    1. KB    = KB.9
       z     = GenKey(KB.9)
       z.1   = Correct(GenKey(KB.9), REC(GenKey(KB.9)))
    
    2. KB    = Sift_key(Measure(Encode(RawKey(key(Noise(z.12), BA(x.15))),
                                       BA(x.15)),
                                BB(x.16)),
                        BA(x.15), BB(x.16))
       z     = Noise(z.12)
       z.1   = z.12
    
    3. KB    = Sift_key(RawKey(key(Noise(z.12), BA(x.15))), BA(x.15),
                        BB(x.16))
       z     = Noise(z.12)
       z.1   = z.12
  */

lemma Executability [sources]:
  exists-trace
  "∃ A B sid Kab #i #j.
    (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
    (CommitKey_B( A, B, sid, Kab ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ A B sid Kab #i #j.
  (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
  (CommitKey_B( A, B, sid, Kab ) @ #j)"
*/
induction
  case non_empty_trace
  simplify
  solve( (last(#j))  ∥ (last(#i)) )
    case case_2
    solve( KeywithErrorA( 'A', 'B', ~sid, KA ) ▶₀ #i )
      case Alice_Paramater_Estimation_NoEve_case_2
      solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
        case ChanIn_Auth
        solve( KeywithErrorB( 'A', 'B', ~sid, Sift_key(x, BA(x.1), BB(x.2))
               ) ▶₀ #j )
          case Bob_Paramater_Estimation_NoEve
          solve( splitEqs(2) )
            case split_case_2
            solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.6 )
              case ChanIn_Auth
              solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.16 )
                case ChanIn_Auth
                solve( In_Auth( 'A', 'B',
                                Sample(Sift_key(RawKey(key(Noise(~Kab), BA(~ba))), BA(~ba), BB(~bb))),
                                'sample'
                       ) ▶₁ #vr.20 )
                  case ChanIn_Auth
                  solve( !KU( mac(Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~Kab),
                                                                            BA(~ba))),
                                                                 BA(~ba)),
                                                          BB(~bb)),
                                                  BA(~ba), BB(~bb))),
                                  ~sid)
                         ) @ #vk.16 )
                    case ChanOut_Auth
                    solve( !KU( mac(REC(Noise(~Kab)), ~sid) ) @ #vk.23 )
                      case ChanOut_Auth
                      solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.28 )
                        case ChanOut_Auth
                        solve( !KU( mac(BA(~ba), ~sid) ) @ #vk.33 )
                          case ChanOut_Auth
                          solve( !KU( mac(Sample(Sift_key(RawKey(key(Noise(~Kab), BA(~ba))),
                                                          BA(~ba), BB(~bb))),
                                          ~sid)
                                 ) @ #vk.35 )
                            case ChanOut_Auth
                            solve( !KU( Sample(Sift_key(Measure(Encode(RawKey(key(Noise(~Kab),
                                                                                  BA(~ba))),
                                                                       BA(~ba)),
                                                                BB(~bb)),
                                                        BA(~ba), BB(~bb)))
                                   ) @ #vk.25 )
                              case ChanOut_Auth_case_1
                              solve( !KU( REC(Noise(~Kab)) ) @ #vk.30 )
                                case ChanOut_Auth_case_1
                                solve( !KU( BB(~bb) ) @ #vk.32 )
                                  case ChanOut_Auth_case_1
                                  solve( !KU( BA(~ba) ) @ #vk.34 )
                                    case ChanOut_Auth_case_1
                                    solve( !KU( Sample(Sift_key(RawKey(key(Noise(~Kab), BA(~ba))), BA(~ba),
                                                                BB(~bb)))
                                           ) @ #vk.35 )
                                      case ChanOut_Auth_case_1
                                      SOLVED // trace found
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma messsage_authenticiation [sources]:
  all-traces
  "∀ A B msg #i.
    (AChanIn( A, B, msg ) @ #i) ⇒ (∃ #k. AChanOut( A, msg ) @ #k)"
/*
guarded formula characterizing all counter-examples:
"∃ A B msg #i.
  (AChanIn( A, B, msg ) @ #i) ∧ ∀ #k. (AChanOut( A, msg ) @ #k) ⇒ ⊥"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #k. (AChanOut( A, <msg, type> ) @ #k) ∧ ¬(last(#k))) )
    case case_1
    solve( !AuthSession( B, key_roleB ) ▶₀ #i )
      case Alice_quantum_phase
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_1
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_1
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_2
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_3
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_4
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_5
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_2
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_1
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_2
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_3
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_4
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_5
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_3
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_1
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_2
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_3
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_4
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_5
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma secret_key_A:
  all-traces
  "∀ A B sid Kab #init #i #j.
    (((SessionInitA( A, B, sid ) @ #init) ∧
      (CommitKey_A( A, B, sid, Kab ) @ #i)) ∧
     (K( Kab ) @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ A B sid Kab #init #i #j.
  (SessionInitA( A, B, sid ) @ #init) ∧
  (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
  (K( Kab ) @ #j)"
*/
simplify
solve( SessionA( 'A', B, ~sid ) ▶₂ #init )
  case Setup
  solve( KeywithErrorA( 'A', B, ~sid, KA ) ▶₀ #i )
    case Alice_Paramater_Estimation_NoEve_case_1
    by solve( In_Auth( 'A', 'A', EB, 'error' ) ▶₁ #i )
  next
    case Alice_Paramater_Estimation_NoEve_case_2
    solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
      case ChanIn_Auth
      solve( !KU( ~kab ) @ #vk )
        case ChanOut_Auth_case_1
        solve( (#vr.23, 0) ~~> (#vk, 0) )
          case Var_fresh_kab
          solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.16 )
            case ChanOut_Auth
            by contradiction /* cyclic */
          next
            case QChan_Adv_Measure
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_3
              by contradiction /* cyclic */
            next
              case c_BA
              solve( !KU( ~ba ) @ #vk.24 )
                case ChanOut_Auth
                by contradiction /* cyclic */
              qed
            qed
          next
            case c_key
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_3
              by contradiction /* cyclic */
            next
              case c_BA
              solve( !KU( ~ba ) @ #vk.24 )
                case ChanOut_Auth
                by contradiction /* cyclic */
              qed
            qed
          qed
        qed
      next
        case ChanOut_Auth_case_2
        solve( (#vr.23, 0) ~~> (#vk, 0) )
          case Var_fresh_kab
          solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.16 )
            case ChanOut_Auth
            by contradiction /* cyclic */
          next
            case QChan_Adv_Measure
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_3
              by contradiction /* cyclic */
            next
              case c_BA
              solve( !KU( ~ba ) @ #vk.24 )
                case ChanOut_Auth
                by contradiction /* cyclic */
              qed
            qed
          next
            case c_key
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_3
              by contradiction /* cyclic */
            next
              case c_BA
              solve( !KU( ~ba ) @ #vk.24 )
                case ChanOut_Auth
                by contradiction /* cyclic */
              qed
            qed
          qed
        qed
      next
        case ChanOut_Auth_case_3
        solve( (#vr.25, 0) ~~> (#vk, 0) )
          case Var_fresh_kab
          solve( !KU( ~sid ) @ #vk.23 )
            case ChanOut_Auth
            by contradiction /* cyclic */
          qed
        qed
      next
        case ChanOut_Auth_case_4
        solve( (#vr.25, 0) ~~> (#vk, 0) )
          case Var_fresh_kab
          solve( !KU( ~sid ) @ #vk.23 )
            case ChanOut_Auth
            by contradiction /* cyclic */
          qed
        qed
      next
        case QChan_Adv_Measure_case_1
        solve( splitEqs(2) )
          case split_case_1
          solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.16 )
            case c_key
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case c_BA
              by solve( !KU( ~ba ) @ #vk.25 )
            qed
          qed
        next
          case split_case_2
          solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.16 )
            case c_key
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case c_BA
              by solve( !KU( ~ba ) @ #vk.25 )
            qed
          qed
        qed
      next
        case QChan_Adv_Measure_case_2
        solve( splitEqs(2) )
          case split_case_1
          solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.16 )
            case c_key
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case c_BA
              by solve( !KU( ~ba ) @ #vk.25 )
            qed
          qed
        next
          case split_case_2
          solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.16 )
            case c_key
            solve( !KU( BA(~ba) ) @ #vk.17 )
              case ChanOut_Auth_case_1
              by contradiction /* cyclic */
            next
              case ChanOut_Auth_case_2
              by contradiction /* cyclic */
            next
              case c_BA
              by solve( !KU( ~ba ) @ #vk.25 )
            qed
          qed
        qed
      next
        case QChan_Adv_Measure_case_3
        solve( splitEqs(2) )
          case split_case_1
          solve( !KU( BA(~ba) ) @ #vk.17 )
            case ChanOut_Auth_case_1
            by contradiction /* cyclic */
          next
            case ChanOut_Auth_case_2
            by contradiction /* cyclic */
          next
            case c_BA
            by solve( !KU( ~ba ) @ #vk.24 )
          qed
        next
          case split_case_2
          solve( !KU( BA(~ba) ) @ #vk.17 )
            case ChanOut_Auth_case_1
            by contradiction /* cyclic */
          next
            case ChanOut_Auth_case_2
            by contradiction /* cyclic */
          next
            case c_BA
            by solve( !KU( ~ba ) @ #vk.24 )
          qed
        qed
      next
        case QChan_Adv_Measure_case_4
        solve( splitEqs(2) )
          case split_case_1
          solve( !KU( BA(~ba) ) @ #vk.17 )
            case ChanOut_Auth_case_1
            by contradiction /* cyclic */
          next
            case ChanOut_Auth_case_2
            by contradiction /* cyclic */
          next
            case c_BA
            by solve( !KU( ~ba ) @ #vk.25 )
          qed
        next
          case split_case_2
          solve( !KU( BA(~ba) ) @ #vk.17 )
            case ChanOut_Auth_case_1
            by contradiction /* cyclic */
          next
            case ChanOut_Auth_case_2
            by contradiction /* cyclic */
          next
            case c_BA
            by solve( !KU( ~ba ) @ #vk.25 )
          qed
        qed
      qed
    qed
  next
    case Alice_Paramater_Estimation_NoEve_case_3
    solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
      case ChanIn_Auth
      solve( !KU( ~kab ) @ #vk )
        case ChanOut_Auth_case_1
        solve( splitEqs(2) )
          case split_case_1
          solve( !KU( Noise(~kab) ) @ #vk.18 )
            case c_Noise
            by contradiction /* cyclic */
          qed
        next
          case split_case_2
          solve( !KU( Noise(~kab) ) @ #vk.18 )
            case c_Noise
            by contradiction /* cyclic */
          qed
        qed
      next
        case ChanOut_Auth_case_2
        by solve( !KU( ~sid ) @ #vk.18 )
      qed
    qed
  qed
qed

lemma secret_key_B:
  all-traces
  "∀ A B sid Kab #init #i #j.
    (((SessionInitB( A, B, sid ) @ #init) ∧
      (CommitKey_B( A, B, sid, Kab ) @ #i)) ∧
     (K( Kab ) @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ A B sid Kab #init #i #j.
  (SessionInitB( A, B, sid ) @ #init) ∧
  (CommitKey_B( A, B, sid, Kab ) @ #i) ∧
  (K( Kab ) @ #j)"
*/
simplify
solve( SessionB( A, 'B', ~sid ) ▶₁ #init )
  case Setup
  solve( In_QuantumChannel( A, 'B', qA ) ▶₂ #init )
    case Chan_In_Forward
    solve( KeywithErrorB( 'A', 'B', ~sid, KB ) ▶₀ #i )
      case Bob_Paramater_Estimation_NoEve
      solve( splitEqs(1) )
        case split_case_1
        solve( !KU( ~kab ) @ #vk )
          case ChanOut_Auth_case_1
          solve( splitEqs(2) )
            case split_case_1
            solve( !KU( Noise(~kab) ) @ #vk.4 )
              case c_Noise
              by contradiction /* cyclic */
            qed
          next
            case split_case_2
            solve( !KU( Noise(~kab) ) @ #vk.4 )
              case c_Noise
              by contradiction /* cyclic */
            qed
          qed
        next
          case ChanOut_Auth_case_2
          by solve( !KU( ~sid ) @ #vk.4 )
        qed
      next
        case split_case_2
        solve( !KU( Correct(GenKey(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                      BA(~ba))),
                                                           BA(~ba)),
                                                    BB(~bb)),
                                            BA, BB(~bb))),
                            REC(GenKey(Sift_key(Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                                               BA(~ba)),
                                                        BB(~bb)),
                                                BA, BB(~bb)))))
               ) @ #vk )
          case c_Correct
          solve( !KU( GenKey(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                BA(~ba))),
                                                     BA(~ba)),
                                              BB(~bb)),
                                      BA, BB(~bb)))
                 ) @ #vk.4 )
            case c_GenKey
            solve( !KU( REC(GenKey(Sift_key(Measure(Encode(RawKey(key(Noise(~kab),
                                                                      BA(~ba))),
                                                           BA(~ba)),
                                                    BB(~bb)),
                                            BA, BB(~bb))))
                   ) @ #vk.5 )
              case ChanOut_Auth_case_1
              solve( !KU( Sift_key(Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                                  BA(~ba)),
                                           BB(~bb)),
                                   BA, BB(~bb))
                     ) @ #vk.6 )
                case c_Sift_key
                by solve( !KU( Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                              BA(~ba)),
                                       BB(~bb))
                          ) @ #vk.7 )
              qed
            next
              case ChanOut_Auth_case_2
              by solve( !KU( ~sid ) @ #vk.7 )
            next
              case c_REC
              solve( !KU( Sift_key(Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                                  BA(~ba)),
                                           BB(~bb)),
                                   BA, BB(~bb))
                     ) @ #vk.6 )
                case c_Sift_key
                by solve( !KU( Measure(Encode(RawKey(key(Noise(~kab), BA(~ba))),
                                              BA(~ba)),
                                       BB(~bb))
                          ) @ #vk.7 )
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case QChan_Create_State
    solve( KeywithErrorB( A, 'B', ~sid, KB ) ▶₀ #i )
      case Bob_Paramater_Estimation_NoEve
      solve( splitEqs(1) )
        case split_case_1
        solve( !KU( Correct(GenKey(Sift_key(Measure(Encode(RawKey(KE), BA),
                                                    BB(~bb)),
                                            BA.1, BB(~bb))),
                            REC(GenKey(Sift_key(Measure(Encode(RawKey(KE), BA), BB(~bb)), BA.1,
                                                BB(~bb)))))
               ) @ #vk )
          case c_Correct
          solve( !KU( GenKey(Sift_key(Measure(Encode(RawKey(KE), BA), BB(~bb)),
                                      BA.1, BB(~bb)))
                 ) @ #vk.9 )
            case c_GenKey
            solve( !KU( REC(GenKey(Sift_key(Measure(Encode(RawKey(KE), BA), BB(~bb)),
                                            BA.1, BB(~bb))))
                   ) @ #vk.10 )
              case ChanOut_Auth_case_1
              solve( !KU( Sift_key(Measure(Encode(RawKey(KE), BA), BB(~bb)), BA.1,
                                   BB(~bb))
                     ) @ #vk.11 )
                case c_Sift_key
                solve( !KU( Measure(Encode(RawKey(KE), BA), BB(~bb)) ) @ #vk.12 )
                  case QChan_Adv_Measure
                  solve( !KU( BB(~bb) ) @ #vk.14 )
                    case ChanOut_Auth_case_1
                    solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.12 )
                      case c_key
                      solve( !KU( BA(~ba) ) @ #vk.13 )
                        case ChanOut_Auth_case_1
                        solve( !KU( Noise(~kab) ) @ #vk.15 )
                          case QChan_Adv_Measure
                          by contradiction /* cyclic */
                        next
                          case c_Noise
                          solve( !KU( ~kab ) @ #vk.16 )
                            case QChan_Adv_Measure_case_1
                            by contradiction /* cyclic */
                          next
                            case QChan_Adv_Measure_case_2
                            by contradiction /* cyclic */
                          qed
                        qed
                      next
                        case ChanOut_Auth_case_2
                        by solve( !KU( ~sid ) @ #vk.16 )
                      next
                        case c_BA
                        by solve( !KU( ~ba ) @ #vk.16 )
                      qed
                    qed
                  next
                    case ChanOut_Auth_case_2
                    by solve( !KU( ~sid ) @ #vk.15 )
                  next
                    case c_BB
                    by solve( !KU( ~bb ) @ #vk.15 )
                  qed
                qed
              qed
            next
              case ChanOut_Auth_case_2
              by solve( !KU( ~sid ) @ #vk.12 )
            next
              case c_REC
              solve( !KU( Sift_key(Measure(Encode(RawKey(KE), BA), BB(~bb)), BA.1,
                                   BB(~bb))
                     ) @ #vk.11 )
                case c_Sift_key
                solve( !KU( Measure(Encode(RawKey(KE), BA), BB(~bb)) ) @ #vk.12 )
                  case QChan_Adv_Measure
                  solve( !KU( BB(~bb) ) @ #vk.14 )
                    case ChanOut_Auth_case_1
                    solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.12 )
                      case c_key
                      solve( !KU( BA(~ba) ) @ #vk.13 )
                        case ChanOut_Auth_case_1
                        solve( !KU( Noise(~kab) ) @ #vk.15 )
                          case QChan_Adv_Measure
                          by contradiction /* cyclic */
                        next
                          case c_Noise
                          solve( !KU( ~kab ) @ #vk.16 )
                            case QChan_Adv_Measure_case_1
                            by contradiction /* cyclic */
                          next
                            case QChan_Adv_Measure_case_2
                            by contradiction /* cyclic */
                          qed
                        qed
                      next
                        case ChanOut_Auth_case_2
                        by solve( !KU( ~sid ) @ #vk.16 )
                      next
                        case c_BA
                        by solve( !KU( ~ba ) @ #vk.16 )
                      qed
                    qed
                  next
                    case ChanOut_Auth_case_2
                    by solve( !KU( ~sid ) @ #vk.15 )
                  next
                    case c_BB
                    by solve( !KU( ~bb ) @ #vk.15 )
                  qed
                qed
              qed
            qed
          qed
        qed
      next
        case split_case_2
        solve( splitEqs(2) )
          case split_case_1
          solve( In_Auth( A, 'B',
                          Sample(Sift_key(Measure(Encode(RawKey(key(Noise(Kab), BA(x))), BA(x)),
                                                  BB(~bb)),
                                          BA(x), BB(~bb))),
                          'sample'
                 ) ▶₁ #vr.5 )
            case ChanIn_Auth
            by solve( In_Auth( 'B', 'B', BA(x), 'sift' ) ▶₁ #vr.7 )
          qed
        next
          case split_case_2
          solve( In_Auth( A, 'B',
                          Sample(Sift_key(RawKey(key(Noise(Kab), BA(x))), BA(x), BB(~bb))),
                          'sample'
                 ) ▶₁ #vr.5 )
            case ChanIn_Auth
            solve( !KU( ~kab ) @ #vk )
              case ChanOut_Auth_case_1
              solve( (#vr.19, 0) ~~> (#vk, 0) )
                case Var_fresh_kab
                solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.9 )
                  case ChanOut_Auth
                  by contradiction /* cyclic */
                next
                  case QChan_Adv_Measure
                  solve( !KU( BA(~ba) ) @ #vk.10 )
                    case ChanOut_Auth_case_1
                    by contradiction /* cyclic */
                  next
                    case ChanOut_Auth_case_2
                    by contradiction /* cyclic */
                  next
                    case ChanOut_Auth_case_3
                    by contradiction /* cyclic */
                  next
                    case c_BA
                    solve( !KU( ~ba ) @ #vk.17 )
                      case ChanOut_Auth
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case c_key
                  solve( !KU( BA(~ba) ) @ #vk.10 )
                    case ChanOut_Auth_case_1
                    by contradiction /* cyclic */
                  next
                    case ChanOut_Auth_case_2
                    by contradiction /* cyclic */
                  next
                    case ChanOut_Auth_case_3
                    by contradiction /* cyclic */
                  next
                    case c_BA
                    solve( !KU( ~ba ) @ #vk.17 )
                      case ChanOut_Auth
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            next
              case ChanOut_Auth_case_2
              solve( (#vr.21, 0) ~~> (#vk, 0) )
                case Var_fresh_kab
                solve( !KU( ~sid ) @ #vk.16 )
                  case ChanOut_Auth
                  by contradiction /* cyclic */
                qed
              qed
            next
              case QChan_Adv_Measure_case_1
              solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.9 )
                case c_key
                solve( !KU( BA(~ba) ) @ #vk.10 )
                  case ChanOut_Auth_case_1
                  by contradiction /* cyclic */
                next
                  case ChanOut_Auth_case_2
                  by contradiction /* cyclic */
                next
                  case c_BA
                  by solve( !KU( ~ba ) @ #vk.19 )
                qed
              qed
            next
              case QChan_Adv_Measure_case_2
              solve( !KU( key(Noise(~kab), BA(~ba)) ) @ #vk.9 )
                case c_key
                solve( !KU( BA(~ba) ) @ #vk.10 )
                  case ChanOut_Auth_case_1
                  by contradiction /* cyclic */
                next
                  case ChanOut_Auth_case_2
                  by contradiction /* cyclic */
                next
                  case c_BA
                  by solve( !KU( ~ba ) @ #vk.18 )
                qed
              qed
            next
              case QChan_Adv_Measure_case_3
              solve( !KU( BA(~ba) ) @ #vk.10 )
                case ChanOut_Auth_case_1
                by contradiction /* cyclic */
              next
                case ChanOut_Auth_case_2
                by contradiction /* cyclic */
              next
                case c_BA
                by solve( !KU( ~ba ) @ #vk.18 )
              qed
            next
              case QChan_Adv_Measure_case_4
              solve( !KU( BA(~ba) ) @ #vk.10 )
                case ChanOut_Auth_case_1
                by contradiction /* cyclic */
              next
                case ChanOut_Auth_case_2
                by contradiction /* cyclic */
              next
                case c_BA
                by solve( !KU( ~ba ) @ #vk.18 )
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case QChan_Create_State_new
    solve( KeywithErrorB( A, 'B', ~sid, KB ) ▶₀ #i )
      case Bob_Paramater_Estimation_NoEve
      solve( !KU( Correct(GenKey(Sift_key(Measure(Encode(key(Noise(KE),
                                                             BA(ba)),
                                                         BA(ba)),
                                                  BB(~bb)),
                                          BA, BB(~bb))),
                          REC(GenKey(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)),
                                                      BB(~bb)),
                                              BA, BB(~bb)))))
             ) @ #vk )
        case c_Correct
        solve( !KU( GenKey(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                   BA(ba)),
                                            BB(~bb)),
                                    BA, BB(~bb)))
               ) @ #vk.9 )
          case c_GenKey
          solve( !KU( REC(GenKey(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                         BA(ba)),
                                                  BB(~bb)),
                                          BA, BB(~bb))))
                 ) @ #vk.10 )
            case ChanOut_Auth_case_1
            solve( !KU( Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)),
                                         BB(~bb)),
                                 BA, BB(~bb))
                   ) @ #vk.11 )
              case c_Sift_key
              by solve( !KU( Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)), BB(~bb))
                        ) @ #vk.12 )
            qed
          next
            case ChanOut_Auth_case_2
            by solve( !KU( ~sid ) @ #vk.12 )
          next
            case c_REC
            solve( !KU( Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)),
                                         BB(~bb)),
                                 BA, BB(~bb))
                   ) @ #vk.11 )
              case c_Sift_key
              by solve( !KU( Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)), BB(~bb))
                        ) @ #vk.12 )
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma aliveness_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ #j. Create_B( 'A', sid ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ #j. (Create_B( 'A', sid ) @ #j) ⇒ ⊥"
*/
simplify
solve( KeywithErrorA( 'A', B, ~sid, KA ) ▶₀ #i )
  case Alice_Paramater_Estimation_NoEve_case_1
  by solve( In_Auth( 'A', 'A', EB, 'error' ) ▶₁ #i )
next
  case Alice_Paramater_Estimation_NoEve_case_2
  by contradiction /* from formulas */
next
  case Alice_Paramater_Estimation_NoEve_case_3
  by contradiction /* from formulas */
qed

lemma aliveness_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ #j. (Create_A( 'B', sid ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ #j. (Create_A( 'B', sid ) @ #j) ⇒ ¬(#j < #i)"
*/
simplify
solve( KeywithErrorB( A, 'B', ~sid, KB ) ▶₀ #i )
  case Bob_Paramater_Estimation_NoEve_case_1
  solve( In_Auth( A, 'B',
                  Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)), BB(~bb)),
                                  BA, BB(~bb))),
                  'sample'
         ) ▶₁ #vr.3 )
    case ChanIn_Auth
    solve( In_Auth( 'B', 'B', BA, 'sift' ) ▶₁ #vr.6 )
      case ChanIn_Auth
      solve( !KU( mac(Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                     BA(ba)),
                                              BB(~bb)),
                                      BB(~bb), BB(~bb))),
                      ~sid)
             ) @ #vk.14 )
        case ChanOut_Auth
        solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.19 )
          case ChanOut_Auth
          solve( !KU( Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                     BA(ba)),
                                              BB(~bb)),
                                      BB(~bb), BB(~bb)))
                 ) @ #vk.15 )
            case ChanOut_Auth_case_1
            solve( !KU( BB(~bb) ) @ #vk.19 )
              case ChanOut_Auth_case_1
              SOLVED // trace found
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma weak_agreement_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ sid2 #j. Running_B( 'A', B, sid2 ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ sid2 #j. (Running_B( 'A', B, sid2 ) @ #j) ⇒ ⊥"
*/
simplify
solve( KeywithErrorA( 'A', B, ~sid, KA ) ▶₀ #i )
  case Alice_Paramater_Estimation_NoEve_case_1
  by solve( In_Auth( 'A', 'A', EB, 'error' ) ▶₁ #i )
next
  case Alice_Paramater_Estimation_NoEve_case_2
  solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth
    by contradiction /* from formulas */
  qed
next
  case Alice_Paramater_Estimation_NoEve_case_3
  solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth
    by contradiction /* from formulas */
  qed
qed

lemma weak_agreement_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ sid2 #j. Running_A( A, 'B', sid2 ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ sid2 #j. (Running_A( A, 'B', sid2 ) @ #j) ⇒ ⊥"
*/
simplify
solve( KeywithErrorB( A, 'B', ~sid, KB ) ▶₀ #i )
  case Bob_Paramater_Estimation_NoEve_case_1
  solve( In_Auth( A, 'B',
                  Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)), BB(~bb)),
                                  BA, BB(~bb))),
                  'sample'
         ) ▶₁ #vr.3 )
    case ChanIn_Auth
    solve( In_Auth( 'B', 'B', BA, 'sift' ) ▶₁ #vr.6 )
      case ChanIn_Auth
      solve( !KU( mac(Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                     BA(ba)),
                                              BB(~bb)),
                                      BB(~bb), BB(~bb))),
                      ~sid)
             ) @ #vk.14 )
        case ChanOut_Auth
        solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.19 )
          case ChanOut_Auth
          solve( !KU( Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                     BA(ba)),
                                              BB(~bb)),
                                      BB(~bb), BB(~bb)))
                 ) @ #vk.15 )
            case ChanOut_Auth_case_1
            solve( !KU( BB(~bb) ) @ #vk.19 )
              case ChanOut_Auth_case_1
              SOLVED // trace found
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ #j. CommitKey_B( 'A', B, sid, kab ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ #j. (CommitKey_B( 'A', B, sid, kab ) @ #j) ⇒ ⊥"
*/
simplify
solve( KeywithErrorA( 'A', B, ~sid, KA ) ▶₀ #i )
  case Alice_Paramater_Estimation_NoEve_case_1
  by solve( In_Auth( 'A', 'A', EB, 'error' ) ▶₁ #i )
next
  case Alice_Paramater_Estimation_NoEve_case_2
  solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth
    by contradiction /* from formulas */
  qed
next
  case Alice_Paramater_Estimation_NoEve_case_3
  solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth
    by contradiction /* from formulas */
  qed
qed

lemma noninjectiveagreement_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ #j. CommitKey_A( A, 'B', sid, kab ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ #j. (CommitKey_A( A, 'B', sid, kab ) @ #j) ⇒ ⊥"
*/
simplify
solve( KeywithErrorB( A, 'B', ~sid, KB ) ▶₀ #i )
  case Bob_Paramater_Estimation_NoEve_case_1
  solve( In_Auth( A, 'B',
                  Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)), BA(ba)), BB(~bb)),
                                  BA, BB(~bb))),
                  'sample'
         ) ▶₁ #vr.3 )
    case ChanIn_Auth
    solve( In_Auth( 'B', 'B', BA, 'sift' ) ▶₁ #vr.6 )
      case ChanIn_Auth
      solve( !KU( mac(Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                     BA(ba)),
                                              BB(~bb)),
                                      BB(~bb), BB(~bb))),
                      ~sid)
             ) @ #vk.14 )
        case ChanOut_Auth
        solve( !KU( mac(BB(~bb), ~sid) ) @ #vk.19 )
          case ChanOut_Auth
          solve( !KU( Sample(Sift_key(Measure(Encode(key(Noise(KE), BA(ba)),
                                                     BA(ba)),
                                              BB(~bb)),
                                      BB(~bb), BB(~bb)))
                 ) @ #vk.15 )
            case ChanOut_Auth_case_1
            solve( !KU( BB(~bb) ) @ #vk.19 )
              case ChanOut_Auth_case_1
              SOLVED // trace found
            qed
          qed
        qed
      qed
    qed
  qed
qed







































/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.8.0
Maude version 3.2.1
Git revision: f172d7f00b1485446a1e7a42dc14623c2189cc42, branch: master
Compiled at: 2023-09-01 08:49:23.916032222 UTC
*/

end==============================================================================
summary of summaries:

analyzed: ./output/PM_Adv_Network_SeqB_REC.spthy

  output:          ./output/PM_Adv_Network_SeqB_REC.proof
  processing time: 59.50s
  
  Executability (exists-trace): verified (21 steps)
  messsage_authenticiation (all-traces): verified (36 steps)
  secret_key_A (all-traces): verified (90 steps)
  secret_key_B (all-traces): verified (104 steps)
  aliveness_A (all-traces): verified (5 steps)
  aliveness_B (all-traces): falsified - found trace (9 steps)
  weak_agreement_A (all-traces): verified (7 steps)
  weak_agreement_B (all-traces): falsified - found trace (9 steps)
  noninjectiveagreement_A (all-traces): verified (7 steps)
  noninjectiveagreement_B (all-traces): falsified - found trace (9 steps)

==============================================================================


