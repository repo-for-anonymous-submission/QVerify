theory EB_Adv_Network_PostM_TWEC_protocol begin

// Function signature and definition of the equational theory E

functions: BA/1, BB/1, Check_NoEve/2, Correct/2, Encode/2, FEC/1,
           GenKey/1, Measure/2[private,destructor], Noise/1, REC/1, Sample/3,
           Sift_key/3, fst/1, genEntpair/2, mac/2[private,destructor], pair/2,
           snd/1, true/0, verifymac/2
equations:
    Check_NoEve(Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(kab),
                                                                  stateid),
                                                       BB(bb)),
                                               BB(bb)),
                                        BA(ba)),
                                BA(ba), BB(bb)),
                       BA(ba), BB(bb)),
                Sample(Sift_key(Measure(genEntpair(Noise(kab), stateid), BB(bb)), BA(ba),
                                BB(bb)),
                       BA(ba), BB(bb)))
  = true,
    Check_NoEve(Sample(Sift_key(Measure(genEntpair(Noise(kab), stateid),
                                        BA(ba)),
                                BA(ba), BB(bb)),
                       BA(ba), BB(bb)),
                Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(kab), stateid),
                                                       BA(ba)),
                                               BA(ba)),
                                        BB(bb)),
                                BA(ba), BB(bb)),
                       BA(ba), BB(bb)))
  = true,
    Check_NoEve(Sample(Sift_key(Measure(genEntpair(Noise(kab), stateid),
                                        BA(ba)),
                                BA(ba), BB(bb)),
                       BA(ba), BB(bb)),
                Sample(Sift_key(Measure(genEntpair(Noise(kab), stateid), BB(bb)), BA(ba),
                                BB(bb)),
                       BA(ba), BB(bb)))
  = true,
    Correct(Noise(kab), <FEC(Noise(kab)), REC(Noise(kab))>) = kab,
    GenKey(Sift_key(Measure(Encode(Measure(genEntpair(Noise(kab), stateid),
                                           BA(ba)),
                                   BA(ba)),
                            BB(bb)),
                    BA(ba), BB(bb)))
  = Noise(kab),
    GenKey(Sift_key(Measure(Encode(Measure(genEntpair(Noise(kab), stateid),
                                           BB(bb)),
                                   BB(bb)),
                            BA(ba)),
                    BA(ba), BB(bb)))
  = Noise(kab),
    GenKey(Sift_key(Measure(genEntpair(Noise(kab), stateid), BA(ba)), BA(ba),
                    BB(bb)))
  = Noise(kab),
    GenKey(Sift_key(Measure(genEntpair(Noise(kab), stateid), BB(bb)), BA(ba),
                    BB(bb)))
  = Noise(kab),
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verifymac(mac(msg, key), key) = msg





restriction Eq_checks_succeed:
  "∀ x y #j. (Eq( x, y ) @ #j) ⇒ (x = y)"
  // safety formula

restriction Neq_checks_succeed:
  "∀ x #j. (Neq( x, x ) @ #j) ⇒ (⊥)"
  // safety formula

restriction OnlyOnce:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Setup:
   [ In( <A, B> ), Fr( ~sid ) ]
  --[ OnlyOnce( ) ]->
   [ SessionA( A, B, ~sid ), SessionB( A, B, ~sid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Charlie_Source_quantum_phase:
   [ Fr( ~stateid ), Fr( ~kab ) ]
  --[
  EveKnownsA( genEntpair(Noise(~kab), ~stateid) ),
  EveKnownsB( genEntpair(Noise(~kab), ~stateid) )
  ]->
   [
   QuantumA( genEntpair(Noise(~kab), ~stateid) ),
   QuantumB( genEntpair(Noise(~kab), ~stateid) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Chan_In_Forward_A:
   [ QuantumA( qA ), In( <X, Y> ) ]
  --[ EveForgetsA( qA ) ]->
   [ In_QuantumChannel( X, qA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Chan_In_Forward_B:
   [ QuantumB( qB ), In( Y ) ]
  --[ EveForgetsB( qB ) ]->
   [ In_QuantumChannel( Y, qB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Adv_Measure_A:
   [ In( <U, BU> ), QuantumA( qA ) ]
  --[ EveForgetsA( qA ) ]->
   [
   Out( Measure(qA, BU) ),
   In_QuantumChannel( U, Encode(Measure(qA, BU), BU) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) QChan_Adv_Measure_B:
   [ In( <U, BU> ), QuantumB( qB ) ]
  --[ EveForgetsB( qB ) ]->
   [
   Out( Measure(qB, BU) ),
   In_QuantumChannel( U, Encode(Measure(qB, BU), BU) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ChanOut_Auth:
   [ !AuthSession( roleA, key_roleA ), Out_Auth( roleA, roleB, msg, type ) ]
  --[ AChanOut( roleA, <msg, type> ) ]->
   [
   !Auth( roleA, msg, mac(msg, key_roleA), type ),
   Out( <roleA, roleB, msg, mac(msg, key_roleA), type> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ChanIn_Auth:
   [
   !AuthSession( roleB, key_roleB ), !Auth( roleA, msg, tag, type ),
   In( roleB )
   ]
  --[
  Eq( msg, verifymac(tag, key_roleB) ),
  AChanIn( roleA, roleB, <msg, type> )
  ]->
   [ In_Auth( roleA, roleB, msg, type ) ]

  /*
  rule (modulo AC) ChanIn_Auth:
     [
     !AuthSession( roleB, key_roleB ), !Auth( roleA, msg, tag, type ),
     In( roleB )
     ]
    --[ Eq( msg, z ), AChanIn( roleA, roleB, <msg, type> ) ]->
     [ In_Auth( roleA, roleB, msg, type ) ]
    variants (modulo AC)
    1. key_roleB
             = key_roleB.8
       tag   = tag.8
       z     = verifymac(tag.8, key_roleB.8)
    
    2. key_roleB
             = x.8
       tag   = mac(x.12, x.8)
       z     = x.12
  */

rule (modulo E) Alice_quantum_phase:
   [ Fr( ~ba ), In_QuantumChannel( 'A', qA ), SessionA( 'A', Y, ~sid ) ]
  --[ SessionInitA( 'A', Y, ~sid ), Create_A( 'B', ~sid ) ]->
   [
   !AuthSession( 'A', ~sid ),
   MeasuredA( 'A', Y, ~sid, Measure(qA, BA(~ba)) ),
   AliceBasis( 'A', Y, ~sid, BA(~ba) ), GetBobBasis( 'A', Y, ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Send_BA:
   [ AliceBasis( 'A', Y, sid, BA ) ]
  --[ Send_BA( 'A', Y, BA ) ]->
   [ Out_Auth( 'A', Y, BA, 'sift' ), Alice_Sent_BA( 'A', Y, BA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Receive_BB:
   [ GetBobBasis( 'A', Y, sid ), In_Auth( Y, 'A', BB, 'sift' ) ]
  --[ Receive_BB( Y, 'A', BB ) ]->
   [ Alice_Received_BB( 'A', Y, BB ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice_SiftA:
   [
   MeasuredA( 'A', Y, sid, KAraw ), Alice_Sent_BA( 'A', Y, BA ),
   Alice_Received_BB( 'A', Y, BB )
   ]
  --[
  Running_A( 'A', Y, sid ), SiftA( 'A', Y, sid, Sift_key(KAraw, BA, BB) )
  ]->
   [
   SifttedKeyA( 'A', Y, sid, Sift_key(KAraw, BA, BB) ),
   SampleKeyA( 'A', Y, sid, BA, BB, Sift_key(KAraw, BA, BB) ),
   GetSampleA( 'A', Y, sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Send_SampleA:
   [ SampleKeyA( 'A', Y, ~sid, BA, BB, KA ) ]
  --[ Send_SampleA( 'A', Y, Sample(KA, BA, BB) ) ]->
   [
   Out_Auth( 'A', Y, Sample(KA, BA, BB), 'sample' ),
   Alice_Sent_KsampleA( 'A', Y, ~sid, Sample(KA, BA, BB) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Receive_SampleB:
   [ GetSampleA( 'A', Y, ~sid ), In_Auth( Y, 'A', KsampleB, 'sample' ) ]
  --[ Receive_SampleB( Y, 'A', KsampleB ) ]->
   [ Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Paramater_Estimation_NoEve:
   [
   SifttedKeyA( 'A', Y, ~sid, KA ),
   Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
   Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
   ]
  --[ Eq( true, Check_NoEve(KsampleA, KsampleB) ) ]->
   [ KeywithErrorA( 'A', Y, ~sid, KA ) ]

  /*
  rule (modulo AC) Alice_Paramater_Estimation_NoEve:
     [
     SifttedKeyA( 'A', Y, ~sid, KA ),
     Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
     Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
     ]
    --[ Eq( true, z ) ]->
     [ KeywithErrorA( 'A', Y, ~sid, KA ) ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.9
       KsampleB
             = KsampleB.10
       z     = Check_NoEve(KsampleA.9, KsampleB.10)
    
    2. KsampleA
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.12), x.13),
                                                      BB(x.14)),
                                              BB(x.14)),
                                       BA(x.15)),
                               BA(x.15), BB(x.14)),
                      BA(x.15), BB(x.14))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BB(x.14)),
                               BA(x.15), BB(x.14)),
                      BA(x.15), BB(x.14))
       z     = true
    
    3. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BA(x.14)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       KsampleB
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.12), x.13),
                                                      BA(x.14)),
                                              BA(x.14)),
                                       BB(x.15)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       z     = true
    
    4. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BA(x.14)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BB(x.15)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       z     = true
  */

rule (modulo E) Alice_Paramater_Estimation_Eve:
   [
   Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
   Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
   ]
  --[
  Neq( true, Check_NoEve(KsampleA, KsampleB) ),
  EveDetected_A( 'A', Y, ~sid )
  ]->
   [ ]

  /*
  rule (modulo AC) Alice_Paramater_Estimation_Eve:
     [
     Alice_Sent_KsampleA( 'A', Y, ~sid, KsampleA ),
     Alice_Received_KsampleB( 'A', Y, ~sid, KsampleB )
     ]
    --[ Neq( true, z ), EveDetected_A( 'A', Y, ~sid ) ]->
     [ ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleB.9
       z     = Check_NoEve(KsampleA.8, KsampleB.9)
    
    2. KsampleA
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.11), x.12),
                                                      BB(x.13)),
                                              BB(x.13)),
                                       BA(x.14)),
                               BA(x.14), BB(x.13)),
                      BA(x.14), BB(x.13))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BB(x.13)),
                               BA(x.14), BB(x.13)),
                      BA(x.14), BB(x.13))
       z     = true
    
    3. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BA(x.13)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       KsampleB
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.11), x.12),
                                                      BA(x.13)),
                                              BA(x.13)),
                                       BB(x.14)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       z     = true
    
    4. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BA(x.13)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BB(x.14)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       z     = true
  */

rule (modulo E) Bob_quantum_phase:
   [ Fr( ~bb ), SessionB( X, 'B', ~sid ), In_QuantumChannel( 'B', qB ) ]
  --[ SessionInitB( X, 'B', ~sid ), Create_B( 'A', ~sid ) ]->
   [
   !AuthSession( 'B', ~sid ),
   MeasuredB( X, 'B', ~sid, Measure(qB, BB(~bb)) ),
   BobBasis( X, 'B', ~sid, BB(~bb) ), GetAliceBasis( X, 'B', ~sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Send_BB:
   [ BobBasis( X, 'B', sid, BB ) ]
  --[ Send_BB( 'B', X, BB ) ]->
   [ Out_Auth( 'B', X, BB, 'sift' ), Bob_Sent_BB( 'B', X, BB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Receive_BA:
   [ GetAliceBasis( X, 'B', sid ), In_Auth( X, 'B', BA, 'sift' ) ]
  --[ Receive_BA( X, 'B', BA ) ]->
   [ Bob_Received_BA( X, 'B', BA ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob_SiftB:
   [
   MeasuredB( X, 'B', sid, KBraw ), Bob_Sent_BB( 'B', X, BB ),
   Bob_Received_BA( X, 'B', BA )
   ]
  --[
  Running_B( X, 'B', sid ), SiftB( X, 'B', sid, Sift_key(KBraw, BA, BB) )
  ]->
   [
   SifttedKeyB( X, 'B', sid, Sift_key(KBraw, BA, BB) ),
   SampleKeyB( X, 'B', sid, BA, BB, Sift_key(KBraw, BA, BB) ),
   GetSampleB( X, 'B', sid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Send_SampleB:
   [ SampleKeyB( X, 'B', ~sid, BA, BB, KB ) ]
  --[ Send_SampleB( 'B', X, Sample(KB, BA, BB) ) ]->
   [
   Out_Auth( 'B', X, Sample(KB, BA, BB), 'sample' ),
   Bob_Sent_KsampleB( X, 'B', ~sid, Sample(KB, BA, BB) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Receive_SampleA:
   [ GetSampleB( X, 'B', ~sid ), In_Auth( X, 'B', KsampleA, 'sample' ) ]
  --[ Receive_SampleA( X, 'B', KsampleA ) ]->
   [ Bob_Received_KsampleA( X, 'B', ~sid, KsampleA ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob_Paramater_Estimation_NoEve:
   [
   SifttedKeyB( X, 'B', ~sid, KB ),
   Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
   Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
   ]
  --[ Eq( true, Check_NoEve(KsampleA, KsampleB) ) ]->
   [ KeywithErrorB( X, 'B', ~sid, KB ) ]

  /*
  rule (modulo AC) Bob_Paramater_Estimation_NoEve:
     [
     SifttedKeyB( X, 'B', ~sid, KB ),
     Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
     Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
     ]
    --[ Eq( true, z ) ]->
     [ KeywithErrorB( X, 'B', ~sid, KB ) ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.9
       KsampleB
             = KsampleB.10
       z     = Check_NoEve(KsampleA.9, KsampleB.10)
    
    2. KsampleA
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.12), x.13),
                                                      BB(x.14)),
                                              BB(x.14)),
                                       BA(x.15)),
                               BA(x.15), BB(x.14)),
                      BA(x.15), BB(x.14))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BB(x.14)),
                               BA(x.15), BB(x.14)),
                      BA(x.15), BB(x.14))
       z     = true
    
    3. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BA(x.14)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       KsampleB
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.12), x.13),
                                                      BA(x.14)),
                                              BA(x.14)),
                                       BB(x.15)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       z     = true
    
    4. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BA(x.14)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.12), x.13), BB(x.15)),
                               BA(x.14), BB(x.15)),
                      BA(x.14), BB(x.15))
       z     = true
  */

rule (modulo E) Bob_Paramater_Estimation_Eve:
   [
   Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
   Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
   ]
  --[
  Neq( true, Check_NoEve(KsampleA, KsampleB) ),
  EveDetected_B( X, 'B', ~sid )
  ]->
   [ ]

  /*
  rule (modulo AC) Bob_Paramater_Estimation_Eve:
     [
     Bob_Sent_KsampleB( X, 'B', ~sid, KsampleB ),
     Bob_Received_KsampleA( X, 'B', ~sid, KsampleA )
     ]
    --[ Neq( true, z ), EveDetected_B( X, 'B', ~sid ) ]->
     [ ]
    variants (modulo AC)
    1. KsampleA
             = KsampleA.8
       KsampleB
             = KsampleB.9
       z     = Check_NoEve(KsampleA.8, KsampleB.9)
    
    2. KsampleA
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.11), x.12),
                                                      BB(x.13)),
                                              BB(x.13)),
                                       BA(x.14)),
                               BA(x.14), BB(x.13)),
                      BA(x.14), BB(x.13))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BB(x.13)),
                               BA(x.14), BB(x.13)),
                      BA(x.14), BB(x.13))
       z     = true
    
    3. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BA(x.13)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       KsampleB
             = Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.11), x.12),
                                                      BA(x.13)),
                                              BA(x.13)),
                                       BB(x.14)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       z     = true
    
    4. KsampleA
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BA(x.13)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       KsampleB
             = Sample(Sift_key(Measure(genEntpair(Noise(x.11), x.12), BB(x.14)),
                               BA(x.13), BB(x.14)),
                      BA(x.13), BB(x.14))
       z     = true
  */

rule (modulo E) Alice_Send_FEC:
   [ KeywithErrorA( 'A', Y, ~sid, KA ) ]
  -->
   [
   NKeyA( 'A', Y, ~sid, FEC(GenKey(KA)), GenKey(KA) ),
   Out_Auth( 'A', Y, FEC(GenKey(KA)), 'error' )
   ]

  /*
  rule (modulo AC) Alice_Send_FEC:
     [ KeywithErrorA( 'A', Y, ~sid, KA ) ]
    -->
     [ NKeyA( 'A', Y, ~sid, FEC(z), z ), Out_Auth( 'A', Y, FEC(z), 'error' ) ]
    variants (modulo AC)
    1. KA    = KA.7
       z     = GenKey(KA.7)
    
    2. KA    = Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.10), x.11),
                                               BA(x.12)),
                                       BA(x.12)),
                                BB(x.13)),
                        BA(x.12), BB(x.13))
       z     = Noise(x.10)
    
    3. KA    = Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.10), x.11),
                                               BB(x.12)),
                                       BB(x.12)),
                                BA(x.13)),
                        BA(x.13), BB(x.12))
       z     = Noise(x.10)
    
    4. KA    = Sift_key(Measure(genEntpair(Noise(x.10), x.11), BA(x.12)),
                        BA(x.12), BB(x.13))
       z     = Noise(x.10)
    
    5. KA    = Sift_key(Measure(genEntpair(Noise(x.10), x.11), BB(x.12)),
                        BA(x.13), BB(x.12))
       z     = Noise(x.10)
  */

rule (modulo E) Alice_TWEC:
   [ NKeyA( 'A', Y, ~sid, EA, NKAB ), In_Auth( Y, 'A', EB, 'error' ) ]
  --[ CommitKey_A( 'A', Y, ~sid, Correct(NKAB, <EA, EB>) ) ]->
   [ ]

  /*
  rule (modulo AC) Alice_TWEC:
     [ NKeyA( 'A', Y, ~sid, EA, NKAB ), In_Auth( Y, 'A', EB, 'error' ) ]
    --[ CommitKey_A( 'A', Y, ~sid, z ) ]->
     [ ]
    variants (modulo AC)
    1. EA    = EA.12
       EB    = EB.13
       NKAB  = NKAB.14
       z     = Correct(NKAB.14, <EA.12, EB.13>)
    
    2. EA    = FEC(Noise(z.10))
       EB    = REC(Noise(z.10))
       NKAB  = Noise(z.10)
       z     = z.10
  */

rule (modulo E) Bob_Send_REC:
   [ KeywithErrorB( X, 'B', ~sid, KB ) ]
  -->
   [
   NKeyA( X, 'B', ~sid, REC(GenKey(KB)), GenKey(KB) ),
   Out_Auth( 'B', X, REC(GenKey(KB)), 'error' )
   ]

  /*
  rule (modulo AC) Bob_Send_REC:
     [ KeywithErrorB( X, 'B', ~sid, KB ) ]
    -->
     [ NKeyA( X, 'B', ~sid, REC(z), z ), Out_Auth( 'B', X, REC(z), 'error' ) ]
    variants (modulo AC)
    1. KB    = KB.7
       z     = GenKey(KB.7)
    
    2. KB    = Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.10), x.11),
                                               BA(x.12)),
                                       BA(x.12)),
                                BB(x.13)),
                        BA(x.12), BB(x.13))
       z     = Noise(x.10)
    
    3. KB    = Sift_key(Measure(Encode(Measure(genEntpair(Noise(x.10), x.11),
                                               BB(x.12)),
                                       BB(x.12)),
                                BA(x.13)),
                        BA(x.13), BB(x.12))
       z     = Noise(x.10)
    
    4. KB    = Sift_key(Measure(genEntpair(Noise(x.10), x.11), BA(x.12)),
                        BA(x.12), BB(x.13))
       z     = Noise(x.10)
    
    5. KB    = Sift_key(Measure(genEntpair(Noise(x.10), x.11), BB(x.12)),
                        BA(x.13), BB(x.12))
       z     = Noise(x.10)
  */

rule (modulo E) Bob_TWEC:
   [ NKeyA( X, 'B', ~sid, EB, NKAB ), In_Auth( X, 'B', EA, 'error' ) ]
  --[ CommitKey_B( X, 'B', ~sid, Correct(NKAB, <EA, EB>) ) ]->
   [ ]

  /*
  rule (modulo AC) Bob_TWEC:
     [ NKeyA( X, 'B', ~sid, EB, NKAB ), In_Auth( X, 'B', EA, 'error' ) ]
    --[ CommitKey_B( X, 'B', ~sid, z ) ]->
     [ ]
    variants (modulo AC)
    1. EA    = EA.12
       EB    = EB.13
       NKAB  = NKAB.14
       z     = Correct(NKAB.14, <EA.12, EB.13>)
    
    2. EA    = FEC(Noise(z.10))
       EB    = REC(Noise(z.10))
       NKAB  = Noise(z.10)
       z     = z.10
  */

lemma Executability [sources]:
  exists-trace
  "∃ A B sid Kab #i #j.
    (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
    (CommitKey_B( A, B, sid, Kab ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ A B sid Kab #i #j.
  (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
  (CommitKey_B( A, B, sid, Kab ) @ #j)"
*/
induction
  case non_empty_trace
  simplify
  solve( (last(#j))  ∥ (last(#i)) )
    case case_1
    solve( NKeyA( 'A', 'B', ~sid, EA, NKAB ) ▶₀ #i )
      case Alice_Send_FEC_case_1
      solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
        case ChanIn_Auth_case_2
        solve( NKeyA( 'A', 'B', ~sid, EB, NKAB ) ▶₀ #j )
          case Bob_Send_REC
          solve( In_Auth( 'A', 'B', EA, 'error' ) ▶₁ #j )
            case ChanIn_Auth
            solve( splitEqs(0) )
              case split
              solve( splitEqs(2) )
                case split_case_2
                solve( splitEqs(3) )
                  case split_case_2
                  solve( In_Auth( 'B', 'A',
                                  Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                                  BA(~ba), BB(x)),
                                         BA(~ba), BB(x)),
                                  'sample'
                         ) ▶₁ #vr.4 )
                    case ChanIn_Auth
                    solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.7 )
                      case ChanIn_Auth
                      solve( In_Auth( 'A', 'B',
                                      Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(~ba)),
                                                      BA(~ba), BB(~bb)),
                                             BA(~ba), BB(~bb)),
                                      'sample'
                             ) ▶₁ #vr.19 )
                        case ChanIn_Auth
                        solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.21 )
                          case ChanIn_Auth
                          SOLVED // trace found
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma messsage_authenticiation [sources]:
  all-traces
  "∀ A B msg #i.
    (AChanIn( A, B, msg ) @ #i) ⇒ (∃ #k. AChanOut( A, msg ) @ #k)"
/*
guarded formula characterizing all counter-examples:
"∃ A B msg #i.
  (AChanIn( A, B, msg ) @ #i) ∧ ∀ #k. (AChanOut( A, msg ) @ #k) ⇒ ⊥"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #k. (AChanOut( A, <msg, type> ) @ #k) ∧ ¬(last(#k))) )
    case case_1
    solve( !AuthSession( B, key_roleB ) ▶₀ #i )
      case Alice_quantum_phase_case_1
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    next
      case Alice_quantum_phase_case_2
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    next
      case Alice_quantum_phase_case_3
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    next
      case Alice_quantum_phase_case_4
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_1
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_2
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_3
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    next
      case Bob_quantum_phase_case_4
      solve( !Auth( A, msg, tag, type ) ▶₁ #i )
        case ChanOut_Auth_case_01
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_02
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_03
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_04
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_05
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_06
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_07
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_08
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_09
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_10
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_11
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_12
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_13
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_14
        by contradiction /* from formulas */
      next
        case ChanOut_Auth_case_15
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma secret_key_A:
  all-traces
  "∀ A B sid Kab #init #i #j.
    (((SessionInitA( A, B, sid ) @ #init) ∧
      (CommitKey_A( A, B, sid, Kab ) @ #i)) ∧
     (K( Kab ) @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ A B sid Kab #init #i #j.
  (SessionInitA( A, B, sid ) @ #init) ∧
  (CommitKey_A( A, B, sid, Kab ) @ #i) ∧
  (K( Kab ) @ #j)"
*/
simplify
solve( In_QuantumChannel( 'A', qA ) ▶₁ #init )
  case Chan_In_Forward_A
  solve( SessionA( 'A', B, ~sid ) ▶₂ #init )
    case Setup
    solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
      case Bob_Send_REC_case_4
      solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
        case ChanIn_Auth
        solve( !KU( Correct(Noise(~kab), <REC(Noise(~kab)), REC(Noise(~kab))>)
               ) @ #vk )
          case c_Correct
          solve( !KU( Noise(~kab) ) @ #vk.8 )
            case QChan_Adv_Measure_B
            solve( In_Auth( 'A', 'B',
                            Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid.1), BA(x)),
                                            BA(x), BB(~bb)),
                                   BA(x), BB(~bb)),
                            'sample'
                   ) ▶₁ #vr.7 )
              case ChanIn_Auth
              solve( !KU( BA(~ba) ) @ #vk.8 )
                case ChanOut_Auth_case_1
                solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.10 )
                  case ChanIn_Auth
                  solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.20 )
                    case ChanIn_Auth
                    solve( !KU( BB(bb.1) ) @ #vk.11 )
                      case ChanOut_Auth_case_1
                      solve( !KU( REC(Noise(~kab)) ) @ #vk.11 )
                        case ChanOut_Auth_case_1
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma secret_key_B:
  all-traces
  "∀ A B sid Kab #init #i #j.
    (((SessionInitB( A, B, sid ) @ #init) ∧
      (CommitKey_B( A, B, sid, Kab ) @ #i)) ∧
     (K( Kab ) @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ A B sid Kab #init #i #j.
  (SessionInitB( A, B, sid ) @ #init) ∧
  (CommitKey_B( A, B, sid, Kab ) @ #i) ∧
  (K( Kab ) @ #j)"
*/
simplify
solve( SessionB( A, 'B', ~sid ) ▶₁ #init )
  case Setup
  solve( In_QuantumChannel( 'B', qB ) ▶₂ #init )
    case Chan_In_Forward_A
    solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
      case Alice_Send_FEC_case_4
      solve( In_Auth( 'A', 'B', EA, 'error' ) ▶₁ #i )
        case ChanIn_Auth
        solve( !KU( Correct(Noise(~kab), <FEC(Noise(~kab)), FEC(Noise(~kab))>)
               ) @ #vk )
          case c_Correct
          solve( !KU( Noise(~kab) ) @ #vk.8 )
            case QChan_Adv_Measure_B
            solve( In_Auth( 'B', 'A',
                            Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid.1), BB(x)),
                                            BA(~ba), BB(x)),
                                   BA(~ba), BB(x)),
                            'sample'
                   ) ▶₁ #vr.7 )
              case ChanIn_Auth
              solve( !KU( BB(~bb) ) @ #vk.8 )
                case ChanOut_Auth_case_1
                solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.10 )
                  case ChanIn_Auth
                  solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.20 )
                    case ChanIn_Auth
                    solve( !KU( BA(ba.1) ) @ #vk.11 )
                      case ChanOut_Auth_case_1
                      solve( !KU( FEC(Noise(~kab)) ) @ #vk.11 )
                        case ChanOut_Auth_case_1
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma aliveness_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ #j. Create_B( 'A', sid ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ #j. (Create_B( 'A', sid ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
  case Alice_Send_FEC_case_1
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BA(~ba)),
                                                        BA(~ba)),
                                                 BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Alice_Send_FEC_case_2
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BA(~ba)),
                                                        BA(~ba)),
                                                 BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Alice_Send_FEC_case_3
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by solve( In_Auth( 'A', 'A',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                       BA(~ba), BB(x)),
                              BA(~ba), BB(x)),
                       'sample'
              ) ▶₁ #vr.4 )
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Alice_Send_FEC_case_4
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by solve( In_Auth( 'A', 'A',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                       BA(~ba), BB(x)),
                              BA(~ba), BB(x)),
                       'sample'
              ) ▶₁ #vr.4 )
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Bob_Send_REC_case_1
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_2
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_3
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_4
  by contradiction /* from formulas */
qed

lemma aliveness_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ #j. (Create_A( 'B', sid ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ #j. (Create_A( 'B', sid ) @ #j) ⇒ ¬(#j < #i)"
*/
simplify
solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
  case Alice_Send_FEC_case_1
  by contradiction /* from formulas */
next
  case Alice_Send_FEC_case_2
  by contradiction /* from formulas */
next
  case Alice_Send_FEC_case_3
  by contradiction /* from formulas */
next
  case Alice_Send_FEC_case_4
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_1
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BB(~bb)),
                                                        BB(~bb)),
                                                 BA(x)),
                                         BA(x), BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                         BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  qed
next
  case Bob_Send_REC_case_2
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BB(~bb)),
                                                        BB(~bb)),
                                                 BA(x)),
                                         BA(x), BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                         BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  qed
next
  case Bob_Send_REC_case_3
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by solve( In_Auth( 'B', 'B',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                       BB(~bb)),
                              BA(x), BB(~bb)),
                       'sample'
              ) ▶₁ #vr.4 )
  qed
next
  case Bob_Send_REC_case_4
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by solve( In_Auth( 'B', 'B',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                       BB(~bb)),
                              BA(x), BB(~bb)),
                       'sample'
              ) ▶₁ #vr.4 )
  qed
qed

lemma weak_agreement_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ sid2 #j. Running_B( 'A', B, sid2 ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ sid2 #j. (Running_B( 'A', B, sid2 ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
  case Alice_Send_FEC_case_1
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BA(~ba)),
                                                        BA(~ba)),
                                                 BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Alice_Send_FEC_case_2
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BA(~ba)),
                                                        BA(~ba)),
                                                 BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'A', 'A',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                         BA(~ba), BB(x)),
                                BA(~ba), BB(x)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Alice_Send_FEC_case_3
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by solve( In_Auth( 'A', 'A',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                       BA(~ba), BB(x)),
                              BA(~ba), BB(x)),
                       'sample'
              ) ▶₁ #vr.4 )
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Alice_Send_FEC_case_4
  solve( In_Auth( B, 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by solve( In_Auth( 'A', 'A',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                       BA(~ba), BB(x)),
                              BA(~ba), BB(x)),
                       'sample'
              ) ▶₁ #vr.4 )
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by contradiction /* from formulas */
  qed
next
  case Bob_Send_REC_case_1
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_2
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_3
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_4
  by contradiction /* from formulas */
qed

lemma weak_agreement_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ sid2 #j. Running_A( A, 'B', sid2 ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ sid2 #j. (Running_A( A, 'B', sid2 ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
  case Alice_Send_FEC_case_1
  by contradiction /* from formulas */
next
  case Alice_Send_FEC_case_2
  by contradiction /* from formulas */
next
  case Alice_Send_FEC_case_3
  by contradiction /* from formulas */
next
  case Alice_Send_FEC_case_4
  by contradiction /* from formulas */
next
  case Bob_Send_REC_case_1
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BB(~bb)),
                                                        BB(~bb)),
                                                 BA(x)),
                                         BA(x), BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                         BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  qed
next
  case Bob_Send_REC_case_2
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    solve( splitEqs(1) )
      case split_case_1
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(Encode(Measure(genEntpair(Noise(~kab), ~stateid),
                                                                BB(~bb)),
                                                        BB(~bb)),
                                                 BA(x)),
                                         BA(x), BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    next
      case split_case_2
      by solve( In_Auth( 'B', 'B',
                         Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                         BB(~bb)),
                                BA(x), BB(~bb)),
                         'sample'
                ) ▶₁ #vr.4 )
    qed
  qed
next
  case Bob_Send_REC_case_3
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by solve( In_Auth( 'B', 'B',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                       BB(~bb)),
                              BA(x), BB(~bb)),
                       'sample'
              ) ▶₁ #vr.4 )
  qed
next
  case Bob_Send_REC_case_4
  solve( In_Auth( A, 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_1
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_2
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_3
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_4
    by contradiction /* from formulas */
  next
    case ChanIn_Auth_case_5
    by solve( In_Auth( 'B', 'B',
                       Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                       BB(~bb)),
                              BA(x), BB(~bb)),
                       'sample'
              ) ▶₁ #vr.4 )
  qed
qed

lemma noninjectiveagreement_A:
  all-traces
  "∀ B sid kab #i.
    (CommitKey_A( 'A', B, sid, kab ) @ #i) ⇒
    (∃ #j. CommitKey_B( 'A', B, sid, kab ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ B sid kab #i.
  (CommitKey_A( 'A', B, sid, kab ) @ #i)
 ∧
  ∀ #j. (CommitKey_B( 'A', B, sid, kab ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( 'A', B, ~sid, EA, NKAB ) ▶₀ #i )
  case Bob_Send_REC_case_1
  solve( In_Auth( 'B', 'A', EB, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_2
    solve( splitEqs(1) )
      case split_case_2
      solve( In_Auth( 'A', 'B',
                      Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BA(x)), BA(x),
                                      BB(~bb)),
                             BA(x), BB(~bb)),
                      'sample'
             ) ▶₁ #vr.4 )
        case ChanIn_Auth
        solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.7 )
          case ChanIn_Auth
          solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.20 )
            case ChanIn_Auth
            SOLVED // trace found
          qed
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_B:
  all-traces
  "∀ A sid kab #i.
    (CommitKey_B( A, 'B', sid, kab ) @ #i) ⇒
    (∃ #j. CommitKey_A( A, 'B', sid, kab ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ A sid kab #i.
  (CommitKey_B( A, 'B', sid, kab ) @ #i)
 ∧
  ∀ #j. (CommitKey_A( A, 'B', sid, kab ) @ #j) ⇒ ⊥"
*/
simplify
solve( NKeyA( A, 'B', ~sid, EB, NKAB ) ▶₀ #i )
  case Alice_Send_FEC_case_1
  solve( In_Auth( 'A', 'B', EA, 'error' ) ▶₁ #i )
    case ChanIn_Auth_case_2
    solve( splitEqs(1) )
      case split_case_2
      solve( In_Auth( 'B', 'A',
                      Sample(Sift_key(Measure(genEntpair(Noise(~kab), ~stateid), BB(x)),
                                      BA(~ba), BB(x)),
                             BA(~ba), BB(x)),
                      'sample'
             ) ▶₁ #vr.4 )
        case ChanIn_Auth
        solve( In_Auth( 'B', 'A', BB(~bb), 'sift' ) ▶₁ #vr.7 )
          case ChanIn_Auth
          solve( In_Auth( 'A', 'B', BA(~ba), 'sift' ) ▶₁ #vr.20 )
            case ChanIn_Auth
            SOLVED // trace found
          qed
        qed
      qed
    qed
  qed
qed







































/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.8.0
Maude version 3.2.1
Git revision: f172d7f00b1485446a1e7a42dc14623c2189cc42, branch: master
Compiled at: 2023-09-01 08:49:23.916032222 UTC
*/

end==============================================================================
summary of summaries:

analyzed: ./output/EB_Adv_Network_PostM_TWEC.spthy

  output:          ./output/EB_Adv_Network_PostM_TWEC.proof
  processing time: 810.87s
  
  Executability (exists-trace): verified (15 steps)
  messsage_authenticiation (all-traces): verified (134 steps)
  secret_key_A (all-traces): falsified - found trace (14 steps)
  secret_key_B (all-traces): falsified - found trace (14 steps)
  aliveness_A (all-traces): verified (34 steps)
  aliveness_B (all-traces): verified (34 steps)
  weak_agreement_A (all-traces): verified (34 steps)
  weak_agreement_B (all-traces): verified (34 steps)
  noninjectiveagreement_A (all-traces): falsified - found trace (8 steps)
  noninjectiveagreement_B (all-traces): falsified - found trace (8 steps)

==============================================================================


